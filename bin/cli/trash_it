#!/bin/bash
unalias -a
trash_dir="${XDG_DATA_HOME:-$HOME/.local/share}/trash_it"
trash_files="$trash_dir/files"
trash_info="$trash_dir/info"

print_it(){
	massage="${1:-}"
	printf '%s\n' "$massage"
}

show_prompt() {
    answer=""
    prompt=""
    default=""

    if [ -z "${2:-}" ] || [ "${2}" = "Y" ];then
        prompt='Y/n'
        default='Y'
    elif [ "${2}" = "N" ];then
        prompt='y/N'
        default='N'
    fi
	prompt="$1 ${prompt:+[$prompt] }"
	
	printf "%s" "$prompt"
	
	stty -icanon -echo time 0 min 1
	answer="$(head -c1)"
	stty icanon echo
	print_it
	
    [ -z "$answer" ] && answer="$default"
       
	case "$answer" in
		[Yy]) return 0 ;;
		[Nn]) return 1 ;;
	esac
}

# Trash file(s)
trash() {
    for filepath in "$@"; do
        if [ ! -e "$filepath" ]; then
            print_it "File \"$filepath\" not found!"
            continue
        fi

        abs_path=$(readlink -f "$filepath")
        filename=$(basename "$filepath")
        timestamp=$(date +%Y-%m-%dT%H:%M:%S)

        # Handle name collisions
        base="$filename"
        count=1
        while [ -e "$trash_files/$base" ] || [ -e "$trash_info/$base.trashinfo" ]; do
            base="${filename%.*}_$count.${filename##*.}"
            count=$((count + 1))
        done

        mv "$filepath" "$trash_files/$base"

        cat > "$trash_info/$base.trashinfo" <<EOF
[Trash Info]
Path=$abs_path
DeletionDate=$timestamp
EOF

        print_it "Trashed: $filepath â†’ $trash_files/$base"
    done
}

# List trash contents
list_trash() {
    if [ -z "$(ls -A "$trash_files")" ]; then
        printf "Trash is empty."
        return
    fi

    printf "Trash contents:\n"
    for file in "$trash_files"/*; do
        [ -e "$file" ] || continue
        base=$(basename "$file")
        info_file="$trash_info/$base.trashinfo"
        path=$(grep '^Path=' "$info_file" | cut -d= -f2-)
        date=$(grep '^DeletionDate=' "$info_file" | cut -d= -f2-)
        print_it "  $base"
        print_it "    Original: $path"
        print_it "    Deleted:  $date"
    done
}

# Restore single file
restore_file() {
    filename="$1"
    info_file="$trash_info/$filename.trashinfo"
    file_path="$trash_files/$filename"

    if [ ! -f "$info_file" ] || [ ! -e "$file_path" ]; then
        print_it "Cannot find file or metadata for: $filename"
        return
    fi

    original=$(grep '^Path=' "$info_file" | cut -d= -f2-)

    if show_prompt "Restore \"$filename\" to \"$original\"?" "N"; then
        mkdir -p "$(dirname "$original")"
        mv "$file_path" "$original"
        rm -f "$info_file"
        print_it "Restored: $original"
    fi
}

# Restore all
restore_all() {
    shopt -s nullglob
    files=("$trash_files"/*)
    if [ ${#files[@]} -eq 0 ]; then
        print_it "Trash is already empty."
        return
    fi

    print_it "Restoring all files..."
    for file in "${files[@]}"; do
        base=$(basename "$file")
        info_file="$trash_info/$base.trashinfo"
        if [ ! -f "$info_file" ]; then
            print_it "Missing metadata for $base. Skipping."
            continue
        fi
        original=$(grep '^Path=' "$info_file" | cut -d= -f2-)
        mkdir -p "$(dirname "$original")"
        mv "$file" "$original" && rm -f "$info_file"
        print_it "Restored: $original"
    done
}

remove_from_trash() {
    for filename in "$@"; do
        info_file="$trash_info/$filename.trashinfo"
        file_path="$trash_files/$filename"

        if [ ! -e "$file_path" ] || [ ! -f "$info_file" ]; then
            print_it "Cannot find trashed file or metadata: $filename"
            continue
        fi

        if show_prompt "Permanently delete \"$filename\"?" "N"; then
            rm -f "$file_path" "$info_file"
            print_it "Deleted: $filename"
        else
            print_it "Skipped: $filename"
        fi
    done
}

# Empty trash
empty_trash() {
    if show_prompt "Empty entire trash permanently?" "N"; then
        rm -rfd "$trash_dir"
        print_it "Trash emptied."
    else
        print_it "Cancelled."
    fi
}

# Help
show_help() {
	script_name="$(basename "$0")"
    cat <<EOF
Trash Utility (FreeDesktop Spec Compliant)

Usage:
  ${script_name} -t file1 [file2 ...]    # Trash file(s)
  ${script_name} -l                      # List contents
  ${script_name} -r filename             # Restore one file
  ${script_name} -R                      # Restore all files
  ${script_name} -e                      # Empty one trash
  ${script_name} -E                      # Empty all trash
  ${script_name} -h                      # Show help

Example:
  ${script_name} -t myfile.txt
  ${script_name} -r myfile.txt
EOF
}

if [ -z "$trash_dir" ]; then
	print_it "[ERROR] $0: variable trash_dir is empty"
	exit 1
fi

mkdir -p "$trash_files" "$trash_info"

# Main argument handler
case "$1" in
    -t|--trash) shift; trash "$@" ;;
    -l|--list) list_trash ;;
    -r|--restore) shift; restore_file "$1" ;;
    -R|--restore-all) restore_all ;;
    -e|--remove_from_trash) empty_trash ;;
    -E|--empty-all) empty_trash ;;
    -h|--help) show_help ;;
    *) trash "$@" ;;
esac
