#!/bin/bash
set -e
unalias -a
. "$__distro_path_lib"
wallpaper_dir="${__distro_path_wallpaper}"

save_wall_only="${1:-false}"
if [ "$save_wall_only" = "save" ];then
	save_wall_only=true
fi

# Get terminal size for preview dimensions
get_preview_dim() {
	# Use FZF env vars if available; fallback to `stty size`
	cols=${FZF_PREVIEW_COLUMNS}
	lines=${FZF_PREVIEW_LINES}

	if [ -z "$cols" ] || [ -z "$lines" ]; then
		# stty size gives rows cols; switch order to colsxrows
		lines=$(tput lines)
		cols=$(tput cols)
	fi

	dim="${cols}x${lines}"

	# Adjust if preview is at the bottom to avoid scrolling issues with Sixel
	if [ -z "$KITTY_WINDOW_ID" ] && [ "$((FZF_PREVIEW_TOP + lines))" -eq "$lines" ]; then
		dim="${cols}x$((lines - 1))"
	fi

	echo "$dim"
}

# Shared dim calculation for preview commands

# Use Kitty's icat if running in Kitty or Ghostty and kitten is available
if { [ -n "$KITTY_WINDOW_ID" ] || [ -n "$GHOSTTY_RESOURCES_DIR" ]; } && command -v kitten >/dev/null 2>&1; then
	preview_command() {
		dim=$(get_preview_dim)
		# 'memory' transfer mode is fastest; 'stream' allows scroll but slower
		RESET=$(printf '\033[m')
		kitten icat --clear --transfer-mode=memory --unicode-placeholder --stdin=no --place="${dim}@0x0" "$1" \
			| sed '$d' | sed $'$s/$/\e[m/'	# Remove last newline and append ANSI reset
	}
elif command -v ueberzugpp >/dev/null 2>&1; then
    cleanup() {
    	if [ -f "$UEBERZUG_FIFO" ];then
        	rm -f "$UEBERZUG_FIFO"
        fi
        kill $(jobs -p) 2>/dev/null || true
    }
    trap cleanup EXIT
	# Define the pipe path
	export UEBERZUG_FIFO="/tmp/ueberzugpp-$(id -u).fifo"

	# Create the pipe and start ueberzugpp in the background
	[ -p "$UEBERZUG_FIFO" ] || mkfifo "$UEBERZUG_FIFO"
	tail -f "$UEBERZUG_FIFO" | ueberzugpp layer --silent &

	preview_command() {
		# Extract dimensions from your helper
		dim=$(get_preview_dim) 

		# Parsing WxH@XxY format
		W=$(echo "$dim" | cut -d'@' -f1 | cut -d'x' -f1)
		H=$(echo "$dim" | cut -d'@' -f1 | cut -d'x' -f2)
		X=$(echo "$dim" | cut -d'@' -f2 | cut -d'x' -f1)
		Y=$(echo "$dim" | cut -d'@' -f2 | cut -d'x' -f2)

		# We use a static identifier like "preview" so that 
		# ueberzugpp replaces the old image instead of stacking them.
		if [ -n "$1" ]; then
			printf '{"action": "add", "identifier": "preview", "x": %d, "y": %d, "width": %d, "height": %d, "path": "%s"}\n' \
			"$X" "$Y" "$W" "$H" "$1" > "$UEBERZUG_FIFO"
		else
			# Clear the preview if no file is provided
			printf '{"action": "remove", "identifier": "preview"}\n' > "$UEBERZUG_FIFO"
		fi
	}
elif command -v ueberzug >/dev/null 2>&1; then
    cleanup() {
    	if [ -f "$UEBERZUG_FIFO" ];then
        	rm -f "$UEBERZUG_FIFO"
        fi
        kill $(jobs -p) 2>/dev/null || true
    }
    trap cleanup EXIT
	# Define the pipe path
	export UEBERZUG_FIFO="/tmp/ueberzugpp-$(id -u).fifo"

	# Create the pipe and start ueberzugpp in the background
	[ -p "$UEBERZUG_FIFO" ] || mkfifo "$UEBERZUG_FIFO"
	ueberzug layer --silent < "$UEBERZUG_FIFO" &

	preview_command() {
		dim=$(get_preview_dim) 
		
		# Parsing WxH@XxY
		W=$(echo "$dim" | cut -d'@' -f1 | cut -d'x' -f1)
		H=$(echo "$dim" | cut -d'@' -f1 | cut -d'x' -f2)
		X=$(echo "$dim" | cut -d'@' -f2 | cut -d'x' -f1)
		Y=$(echo "$dim" | cut -d'@' -f2 | cut -d'x' -f2)

		if [ -n "$1" ]; then
			# Classic Ueberzug syntax: action identifier x y width height path
			# Note: 'scaler' is often needed in classic to fit the preview box
			printf "action=add,identifier=preview,x=%d,y=%d,width=%d,height=%d,scaler=fit_contain,path=%s\n" \
				"$X" "$Y" "$W" "$H" "$1" > "$UEBERZUG_FIFO"
		else
			printf "action=remove,identifier=preview\n" > "$UEBERZUG_FIFO"
		fi
	}
# Use chafa with Sixel output if available
elif command -v chafa >/dev/null 2>&1; then
	preview_command() {
		dim=$(get_preview_dim)
		chafa -s "$dim" "$1"
		echo	# new line for fzf multiple previews
	}

# Use imgcat for iTerm2 if available
elif command -v imgcat >/dev/null 2>&1; then
	preview_command() {
		dim=$(get_preview_dim)
		# Extract width and height from dim
		w="${dim%x*}"
		h="${dim#*x}"
		imgcat -W "$w" -H "$h" "$1"
	}

# Fallback: use file command for preview
else
	preview_command() {
		file "$1"
	}
fi

export -f preview_command get_preview_dim

FZF_DEFAULT_OPTS=""
FZF_CTRL_R_OPTS=""

picked_wallpaper="$(find "${wallpaper_dir}" -type f | fzf --preview='preview_command {}')"
if [ -n "$picked_wallpaper" ];then
	if [ "$save_wall_only" = false ];then
		setbg -T "${picked_wallpaper}"
	elif [ "$save_wall_only" = true ];then
		setbg -s "${picked_wallpaper}"
	fi
fi
