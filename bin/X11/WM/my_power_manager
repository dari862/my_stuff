#!/bin/sh
set -e

# Load shared environment/config
. "$__distro_path_lib"
. "${__distro_path_root}/lib/common/WM"

# Paths
conf_file="my_power_manager.conf"
usr_conf_path="$script_config_path/$conf_file"
global_conf_ini="${__distro_path_root}/lib/$conf_file"

# Ensure configuration file exists
[ ! -f "$usr_conf_path" ] && cp "$global_conf_ini" "$script_config_path" || :

# Load configuration (only once)
. "$usr_conf_path"

# Trap to restore DPMS on exit
trap "xset s on +dpms; exit" INT TERM

# Disable screen saver and DPMS
xset s 0 0 >/dev/null 2>&1
xset -dpms >/dev/null 2>&1
xset s off >/dev/null 2>&1
xset dpms 0 0 0 >/dev/null 2>&1

# Helper: Set brightness for all displays
set_brightness_on_idle() {
    # Detect displays once number of display some time changes if one of mointer get disconnected
    displays=$(xrandr --query | awk '/ connected/ {print $1}')
    num_displays=$(echo "$displays" | wc -l)
    only_one_display=false
    [ "$num_displays" -eq 1 ] && only_one_display=true
    for display in $displays; do
        xrandr --output "$display" --brightness 0.5
    done
}

# Helper: Find minimum value > 0
min_var_is() {
    minval=$1
    shift
    for val in "$@"; do
        [ "$val" -gt 0 ] && [ "$val" -lt "$minval" ] && minval=$val
    done
    echo "$minval"
}

# Helper: Perform action if time threshold is reached
check_action() {
    action_time=$1
    command=$2
    [ "$action_time" -gt 0 ] && [ "$idleTime" -ge "$action_time" ] && my_session_manager_cli "$command" || :
}

# Convert idleAfter to ms
idleAfterMillis=$((idleAfter * 1000))

# Find the shortest trigger time
min_time_is=$(min_var_is "$idleAfter" "$turnoff_monitor_time" "$logout_time" "$suspend_time" "$hibernate_time" "$poweroff_time")

# Calculate offset
difference_time=$((idleAfter - min_time_is))
[ "$difference_time" -lt 0 ] && difference_time=0

# Main loop
idle=false
while true; do
    idleTimeMillis=$(xprintidle)
    idleTime=$((idleTimeMillis / 1000))
    time_to_sleep=$((idleAfter - difference_time - idleTime))
    [ "$time_to_sleep" -lt 1 ] && time_to_sleep=1

    # Check each power action
    check_action "$turnoff_monitor_time" "monitor_off"
    check_action "$logout_time" "logout"
    check_action "$suspend_time" "suspend"
    check_action "$hibernate_time" "hibernate"
    check_action "$poweroff_time" "shutdown"

    # Handle idle screen state
    if [ "$idleAfter" -gt 0 ] && [ "$idle" = false ] && [ "$idleTimeMillis" -gt "$idleAfterMillis" ]; then
        [ "$brightness_level" -ne 0 ] && set_brightness_on_idle
        [ "$lock_screen_on_idle" = "true" ] && my_session_manager_cli lock
        idle=true
    fi

    # Sleep $min_time_is until next expected action since nothing will happend before this
    if [ "$idle" = false ];then
        sleep "$min_time_is"
    else
        # If idle, wait until activity resumes
        while [ "$(xprintidle)" -gt "$idleAfterMillis" ]; do
            # so we above check at correct time
            sleep "$min_time_is"
        done
        idle=false
    fi
done
