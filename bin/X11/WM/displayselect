#!/bin/bash
# if this line exist script will be part of hub script.
set -e
. "$__distro_path_lib"
. "${__distro_path_root}/lib/common/WM"

pass_arg=""
OPT__="${1:-}"
MODE="${2:-}"
__automate_it=false

if [ "$MODE" = "rofi" ];then
	Menu_="rofi"
	. "${Distro_config_file}"
elif [ "$MODE" = "pass" ];then
	__automate_it=true
	pass_arg="${3:-}"
elif [ "$MODE" = "monitor" ];then
	__automate_it=true
    picked_pass_monitor="${3:-}"
	pass_arg="${4:-}"
    extra_pass_arg="${5:-}"
elif [ "$MODE" = "noninteractive" ];then
	__automate_it=true
fi

postrun_message=""
postrun_title=""
choice=""

RC='\033[0m'
RED='\033[31m'
GREEN='\033[32m'
YELLOW='\033[33m'
CYAN='\033[36m'

printf_message(){
	_type="${1:-}"
	
	if [ "$COLOR" = "YELLOW" ];then
		COLOR="$YELLOW"
	elif [ "$COLOR" = "RED" ];then
		COLOR="$RED"
	elif [ "$COLOR" = "GREEN" ];then
		COLOR="$GREEN"
	else
		COLOR="$CYAN"
	fi
	
	if [ "$_type" = "title" ];then
		printf "%b\n" "${COLOR}=========================================${RC}"
		printf "%b\n" "${COLOR}  ${title}${RC}"
		printf "%b\n" "${COLOR}=========================================${RC}"
	else
		printf "%b\n" "${pre_}${COLOR}${message}${RC}"
	fi
}

show_message(){
	[ "$__automate_it" = true ] && return
	[ "$Menu_" = "rofi" ] && return
	COLOR="$1"
	message="$2"
	pre_="$3"
	printf_message ""
}

show_title(){
	[ "$__automate_it" = true ] && return
	[ "$Menu_" = "rofi" ] && return
	COLOR="$1"
	title="$2"
	pre_=""
	printf_message "title"
}

enter_choice(){
	choice=""
	[ "$__automate_it" = true ] && return
	if [ "$Menu_" = "rofi" ];then
		choice="$(rofi -no-config -no-lazy-grab -sep "|" -dmenu -i -theme "$HOME/.config/rofi/$ROFI_STYLE"/runner.rasi -p "${1:-}")"
	else
		message="${1:-}"
		printf "%b" "$message (or 'q' to quit): "
		read -r choice
		if [ "$choice" = "q" ]; then
			printf "%b\n" "${RED}Exiting...${RC}"
			exit
		fi
	fi
	echo "$choice"
}

list_and_enter_choice(){
	choice=""
	[ "$__automate_it" = true ] && return
	if [ "$Menu_" = "rofi" ];then
		choice="$(printf '%s' "$2" | rofi -no-config -no-lazy-grab -sep "|" -dmenu -i -theme "$HOME/.config/rofi/$ROFI_STYLE"/runner.rasi -p "${1:-}")"
	else
		printf '%s' "$2" | tr '|' '\n' | while IFS= read -r line; do
			printf "${GREEN}%s${RC}\n" "$line"
		done
		enter_choice "$1"
	fi
	echo "$choice"
}

confirm_action() {
	[ "$__automate_it" = true ] && return
	action="$1"
	if [ "$MODE" != "rofi" ];then
		printf "%b\n" "${CYAN}$action"
		printf "%b" "${CYAN}Are you sure? (y/N): "
		read -r confirm
	else
		confirm="$(rofi_menu "$action. Are you sure?" "Yes|No")"
	fi
	
	if printf '%s' "$confirm" | grep -qE '^[Yy]'; then
		return 0
	else
		return 1
	fi
}

Invalid_selection(){
	if [ "$MODE" != "rofi" ];then
		show_message "RED" "Invalid selection."
	else
		rofi_menu "ERROR:" "Invalid selection."
	fi
	postrun_title="ERROR"
	postrun_message="Invalid selection."
}

edit_command() {
	var_name="${1:-}"
	var_name="$(printf '%s' "$var_name" | sed 's/-/_/g')"
	var_value="${2:-}"
	sed -i "s/${var_name}=.*/${var_name}=\"${var_value}\"/g" "$display_script"
}

execute_command() {
	command="$1"
	[ "$__automate_it" = false ] && printf "Executing: %s\n" "$command"
	if ! $command 2>&1 | tee /tmp/xrandr.log | tail -n 20; then
		if [ "$MODE" != "rofi" ];then
			show_message "RED" "An error occurred while executing the command. Check /tmp/xrandr.log for details."
		else
			rofi_menu "ERROR" "An error occurred while executing the command. Check /tmp/xrandr.log for details."
		fi
	fi
}

detect_connected_monitors() {
	xrandr_output=$(xrandr)
	printf "%b\n" "$xrandr_output" | grep " connected" | awk '{print $1}'
}

get_current_brightness() {
	monitor="$1"
	xrandr --verbose | grep -A 10 "^$monitor connected" | grep "Brightness:" | awk '{print $2}'
}

get_unique_resolutions() {
	monitor="$1"
	xrandr_output=$(xrandr)
	available_resolutions=$(printf "%s" "$xrandr_output" | sed -n "/$monitor connected/,/^[^ ]/p" | grep -oP '\d+x\d+' | sort -u)
	
	standard_resolutions="1920x1080 1280x720 1600x900 2560x1440 3840x2160"

	filtered_standard_resolutions=$(printf "%s" "$standard_resolutions" | tr ' ' '\n' | grep -xF -f <(printf "%s" "$available_resolutions") | tr '\t' ' ')

	available_resolutions_sorted=$(printf "%s\n" "$available_resolutions" | sort)
	filtered_standard_resolutions_sorted=$(printf "%s\n" "$filtered_standard_resolutions" | sort)
	
	remaining_resolutions=$(comm -23 <(echo "$available_resolutions_sorted") <(echo "$filtered_standard_resolutions_sorted"))
	
	printf "%b\n" "$filtered_standard_resolutions\n$remaining_resolutions" | head -n 10
}

cancel_action(){
	show_message "RED" "Action canceled."
	postrun_message="Action canceled."
	notify_send_and_exit
}

notify_send_and_exit(){
	notify-send "ðŸ’» $postrun_title" "$postrun_message"
	exit
}

#########################################################################################################################
#########################################################################################################################
#########################################################################################################################
#########################################################################################################################
auto_detect_displays() {
	postrun_title="Auto-detect displays and set common resolution"
	confirm_action "Auto-detect displays and set common resolution?" || return
	execute_command "xrandr --auto"
	first_monitor=$(echo "$monitor_list" | head -n 1)
	common_resolutions=$(get_unique_resolutions "$first_monitor")
	for monitor in $monitor_list; do
		resolutions=$(get_unique_resolutions "$monitor")
		temp_common_resolutions=$(printf "%b\n" "$common_resolutions" | sort)
		temp_resolutions=$(printf "%b\n" "$resolutions" | sort)
		common_resolutions=$(comm -12 <(echo "$temp_common_resolutions") <(echo "$temp_resolutions"))
	done
	
	if [ -z "$common_resolutions" ]; then
		show_message "RED" "No common resolution found among connected monitors."
		return
	fi
	highest_resolution=$(echo "$common_resolutions" | sort -n -t'x' -k1,1 -k2,2 | tail -n 1)
	tee "$display_script" <<- EOF >/dev/null 2>&1
	#!/bin/sh
	EOF
	chmod +x "$display_script"
	for monitor in $monitor_list; do
		show_message "YELLOW" "Setting resolution for $monitor to $highest_resolution..."
		fix_script_monitor="$(printf '%s' "$monitor" | sed 's/-/_/g')"
		tee -a "$display_script" <<- EOF2 >/dev/null 2>&1
		${fix_script_monitor}_resolution="--mode $highest_resolution"
		${fix_script_monitor}_primary=""
		${fix_script_monitor}_enable=""
		${fix_script_monitor}_extend=""
		${fix_script_monitor}_brightness=""
		${fix_script_monitor}_duplicate=""
		${fix_script_monitor}_orientation="--rotate normal"
		${fix_script_monitor}_arrangement=""
		${fix_script_monitor}_scale="--scale 1x1"
		${fix_script_monitor}_disable=""
		if [ -z "\$${fix_script_monitor}_enable" ];then
			xrandr --output $monitor \$${fix_script_monitor}_scale \$${fix_script_monitor}_resolution \$${fix_script_monitor}_primary \$${fix_script_monitor}_extend \$${fix_script_monitor}_brightness \$${fix_script_monitor}_duplicate \$${fix_script_monitor}_orientation \$${fix_script_monitor}_arrangement \$${fix_script_monitor}_disable
		else
			xrandr --output $monitor --mode $highest_resolution --auto
		fi
		EOF2
	done
	postrun_message="Setting resolution for $monitor to $highest_resolution..."
}

scale_monitors() {
	postrun_title="Scale Monitors to Highest Resolution"
	show_title "YELLOW" "Scale Monitors to Highest Resolution"
	max_width=0
	max_height=0
	for monitor in $monitor_array; do
		res=$(xrandr | grep -A1 "^$monitor connected" | tail -1 | awk '{print $1}')
		width=$(echo "$res" | awk -Fx '{print $1}')
		height=$(echo "$res" | awk -Fx '{print $2}')
		if [ "$width" -gt "$max_width" ]; then
			max_width=$width
		fi
		if [ "$height" -gt "$max_height" ]; then
			max_height=$height
		fi
	done
	show_message "YELLOW" "Highest resolution found: ${max_width}x${max_height}"
	for monitor in $monitor_array; do
		show_message "YELLOW" "Scaling $monitor to ${max_width}x${max_height}"
		edit_command "${monitor}_scale" "--scale-from ${max_width}x${max_height}"
	done
	show_message "GREEN" "Scaling complete. All monitors are now scaled to ${max_width}x${max_height}."
	postrun_message="Scaling complete. All monitors are now scaled to ${max_width}x${max_height}."
}

set_resolutions() {
    if [ "$MODE" = "monitor" ];then
        edit_command "${picked_pass_monitor}_resolution" "--mode $pass_arg"
        return
    fi
	postrun_title="Monitor configuration set resolutions"
	while true; do
		clear
		show_title "YELLOW" "Monitor Configuration"
		if [ "$monitor_configuration" = "single" ];then
			monitor_name="$monitor_array"
		else
			show_message "YELLOW" "Monitor Configuration:"
			list_and_enter_choice "Choose a monitor to configure:" "$monitor_choices"
			monitor_choice="$choice"
			
			if ! echo "$monitor_choice" | grep -qE '^[0-9]+$' || [ "$monitor_choice" -lt 1 ] || [ "$monitor_choice" -gt "$((i - 1))" ]; then
				Invalid_selection && continue
			fi
			monitor_name=$(echo "$monitor_array" | cut -d' ' -f"$monitor_choice")
		fi
		resolutions=$(get_unique_resolutions "$monitor_name" | sort -rn -t'x' -k1,1 -k2,2)
		resolutions_choose="$(printf "%b\n" "$resolutions" | awk '{print NR " " $0}' | sed 's/ /.\t/g')"
		printf "%b\n" "$resolutions_choose"
		clear
		show_title "YELLOW" "Resolution Configuration for $monitor_name"
		
		while true; do
			enter_choice "Choose resolution Configuration for $monitor_name:"
			resolution_choice="$choice"
			
			if ! echo "$resolution_choice" | grep -qE '^[0-9]+$' || [ "$resolution_choice" -lt 1 ] || [ "$resolution_choice" -gt "$((i - 1))" ]; then
				Invalid_selection && continue
			fi
			selected_resolution=$(echo "$resolutions_choose" | awk "NR==$resolution_choice")
			if confirm_action "Set resolution for $monitor_name to $selected_resolution?";then
				show_message "GREEN" "Setting resolution for $monitor_name to $selected_resolution"
				edit_command "${monitor_name}_resolution" "--mode $selected_resolution"
				postrun_message="Setting resolution for $monitor_name to $selected_resolution"
				break
			else
				cancel_action
			fi
		done
	done
}

set_primary_monitor() {
	postrun_title="Set Primary Monitor"
	[ "$monitor_configuration" = "single" ] && exit
	clear
	show_title "YELLOW" "Set Primary Monitor"
	show_message "YELLOW" "Choose a monitor to set as primary:"
	list_and_enter_choice "Enter the number of the monitor to set as primary:" "$monitor_choices"
	monitor_choice="$choice"
	
	if ! echo "$monitor_choice" | grep -qE '^[0-9]+$' || [ "$monitor_choice" -lt 1 ] || [ "$monitor_choice" -gt "$((i - 1))" ]; then
		Invalid_selection && return
	fi
	monitor_name=$(echo "$monitor_array" | cut -d' ' -f"$monitor_choice")
	if confirm_action "Set $monitor_name as the primary monitor?"; then
		for monitor in $monitor_array; do
			edit_command "${monitor_name}_primary" ""
		done
		show_message "GREEN" "Setting $monitor_name as primary monitor"
		edit_command "${monitor_name}_primary" "--primary"
		show_message "GREEN" "Monitor $monitor_name set as primary successfully."
		postrun_message="Monitor $monitor_name set as primary successfully."
	else
		cancel_action
	fi
}
enable_monitor() {
    if [ "$MODE" = "monitor" ];then
        edit_command "${picked_pass_monitor}_enable" "--auto"
        return
    fi
	postrun_title="Enabling monitor"
	if [ "$monitor_configuration" = "multi-monitor" ]; then
		clear
		show_title "YELLOW" "Enable Monitor"
		if [ "$monitor_configuration" = "single" ];then
			monitor_name="$monitor_array"
		else
			show_message "YELLOW" "Choose a monitor to enable: "
			list_and_enter_choice "Enter the number of the monitor to enable:" "$monitor_choices"
			monitor_choice="$choice"

			if ! echo "$monitor_choice" | grep -qE '^[0-9]+$' || [ "$monitor_choice" -lt 1 ] || [ "$monitor_choice" -gt "$((i - 1))" ]; then
				Invalid_selection && return
			fi
			monitor_name=$(echo "$monitor_array" | cut -d' ' -f"$monitor_choice")
		fi
		if confirm_action "Enable $monitor_name?"; then
			show_message "GREEN" "Enabling $monitor_name"
			edit_command "${monitor_name}_enable" "--auto"
			show_message "GREEN" "Monitor $monitor_name enabled successfully."
			postrun_message="Monitor $monitor_name enabled successfully."
		else
			cancel_action
		fi
	else
		edit_command "${monitor_array}_enable" "--auto"
		postrun_message="Monitor $monitor_name enabled successfully."
	fi
}
extend_displays() {
	postrun_title="Extend displays"
	[ "$monitor_configuration" = "single" ] && exit
	i=1
	for monitor in $monitor_array; do
		prev_monitor=$(echo "$monitor_array" | cut -d' ' -f$((i-1)))
		if confirm_action "Extend $monitor to the right of $prev_monitor?"; then
			show_message "GREEN" "Extending $monitor to the right of $prev_monitor"
			edit_command "${monitor}_extend" "--right-of $prev_monitor"
		fi
		i=$((i + 1))
	done
	postrun_message="Extending $monitor to the right of $prev_monitor"
}
adjust_monitor_brightness() {
	postrun_title="Adjust Monitor Brightness"
	GREEN='\033[32m'
	while true; do
		clear
		show_title "YELLOW" "Adjust Monitor Brightness"
		if [ "$monitor_configuration" = "single" ];then
			monitor_name="$monitor_array"
		else
			show_message "YELLOW" "Choose a monitor to adjust brightness:"
			list_and_enter_choice "Enter the number of the monitor to adjust brightness:" "$monitor_choices"
			monitor_choice="$choice"
			
			if ! echo "$monitor_choice" | grep -qE '^[0-9]+$'; then
				Invalid_selection && continue
			fi
			number_of_monitors=$(echo "$monitor_list" | wc -l)
			if [ "$monitor_choice" -lt 1 ] || [ "$monitor_choice" -gt "$number_of_monitors" ]; then
				Invalid_selection && continue
			fi
			monitor_name=$(echo "$monitor_list" | sed -n "${monitor_choice}p")
		fi
		current_brightness=$(get_current_brightness "$monitor_name")
		current_brightness_percentage=$(awk -v brightness="$current_brightness" 'BEGIN {printf "%.0f", brightness * 100}')
		
		Current_brightness_message_="Current brightness for $monitor_name: ${GREEN}$current_brightness_percentage%"
		show_message "YELLOW" "$Current_brightness_message_"
		while true; do
			enter_choice "Enter the new brightness value as a percentage (10 to 100)"
			new_brightness_percentage="$choice"

			if ! echo "$new_brightness_percentage" | grep -qE '^[0-9]+$' || [ "$new_brightness_percentage" -lt 10 ] || [ "$new_brightness_percentage" -gt 100 ]; then
				Invalid_selection && continue
			fi
			new_brightness=$(awk "BEGIN {printf \"%.2f\", $new_brightness_percentage / 100}")
			if confirm_action "Set brightness for $monitor_name to $new_brightness_percentage%?"; then
				show_message "GREEN" "Setting brightness for $monitor_name to $new_brightness_percentage%"
				edit_command "${monitor_name}_brightness" "--brightness $new_brightness"
				show_message "GREEN" "Brightness for $monitor_name set to $new_brightness_percentage% successfully."
				postrun_message="Brightness for $monitor_name set to $new_brightness_percentage% successfully."
				break
			else
				cancel_action
			fi
		done
	done
}
duplicate_displays() {
	postrun_title="Duplicate displays"
	[ "$monitor_configuration" = "single" ] && exit
	primary=$(echo "$monitor_list" | head -n 1)
	for monitor in $(detect_connected_monitors | tail -n +2); do
		if confirm_action "Duplicate $monitor to $primary?"; then
			show_message "GREEN" "Duplicating $monitor to $primary"
			edit_command "${monitor}_duplicate" "--same-as $primary"
		fi
	done
	postrun_message="Duplicating $monitor to $primary"
}
change_orientation() {
    if [ "$MODE" = "monitor" ];then
        edit_command "${picked_pass_monitor}_orientation" "--rotate $pass_arg"
        return
    fi
	postrun_title="Change Monitor Orientation"
	clear
	show_title "YELLOW" "Change Monitor Orientation"
	if [ "$monitor_configuration" = "single" ];then
		monitor_name="$monitor_array"
	else
		show_message "YELLOW" "Choose a monitor to configure: "
		list_and_enter_choice "Enter the number of the monitor to configure:" "$monitor_choices"
		monitor_choice="$choice"

		if ! echo "$monitor_choice" | grep -qE '^[0-9]+$' || [ "$monitor_choice" -lt 1 ] || [ "$monitor_choice" -gt "$((i - 1))" ]; then
			Invalid_selection && return
		fi
		monitor_name=$(echo "$monitor_array" | cut -d' ' -f"$monitor_choice")
	fi
	clear	
	show_title "YELLOW" "Set Orientation for $monitor_name"
	show_message "YELLOW" "Choose orientation:"

	list_and_enter_choice "Enter the number of the orientation:" "1. Normal|2. Left|3. Right|4. Inverted|"
	orientation_choice="$choice"

	case $orientation_choice in
		1) orientation="normal" ;;
		2) orientation="left" ;;
		3) orientation="right" ;;
		4) orientation="inverted" ;;
		*) Invalid_selection && return ;;
	esac
	if confirm_action "Change orientation of $monitor_name to $orientation?"; then
		show_message "GREEN" "Changing orientation of $monitor_name to $orientation"
		edit_command "${monitor_name}_orientation" "--rotate $orientation"
		show_message "GREEN" "Orientation changed successfully."
		postrun_message="Orientation of $monitor_name to $orientation changed successfully."
	else
		cancel_action
	fi
	postrun_title="Change orientation complete"
}
manage_arrangement() {
    if [ "$MODE" = "monitor" ];then
        edit_command "${picked_pass_monitor}_arrangement" "$pass_arg $extra_pass_arg"
        return
    fi
	postrun_title="Manage Monitor Arrangement"
	[ "$monitor_configuration" = "single" ] && exit
	clear
	show_title "YELLOW" "Manage Monitor Arrangement"
	show_message "YELLOW" "Choose the monitor to arrange: "
	list_and_enter_choice "Enter the number of the monitor to arrange:" "$monitor_choices"
	monitor_choice="$choice"
	
	if ! echo "$monitor_choice" | grep -qE '^[0-9]+$' || [ "$monitor_choice" -lt 1 ] || [ "$monitor_choice" -gt "$((i - 1))" ]; then
		Invalid_selection && return
	fi
	monitor_name=$(echo "$monitor_array" | cut -d' ' -f"$monitor_choice")
	clear

	list_and_enter_choice "Choose position relative to other monitors:" "1. Left of|2. Right of|3. Above|4. Below|"
	position_choice="$choice"

	case $position_choice in
		1) position="--left-of" ;;
		2) position="--right-of" ;;
		3) position="--above" ;;
		4) position="--below" ;;
		*) Invalid_selection && return ;;
	esac
	ref_choices=""
	show_message "YELLOW" "Choose the reference monitor:"
	i=1
	for monitor in $monitor_array; do
		if [ "$monitor" != "$monitor_name" ]; then
			show_message "GREEN" "$monitor" "$i. "
			ref_choices="${ref_choices}$i. $monitor|"
		fi
		i=$((i + 1))
	done

	list_and_enter_choice "Enter the number of the reference monitor:" "${ref_choices}"
	ref_choice="$choice"

	if ! echo "$ref_choice" | grep -qE '^[0-9]+$' || [ "$ref_choice" -lt 1 ] || [ "$ref_choice" -gt "$((i - 1))" ] || [ "$ref_choice" -eq "$monitor_choice" ]; then
		Invalid_selection && return
	fi
	ref_monitor=$(echo "$monitor_array" | cut -d' ' -f"$ref_choice")
	if confirm_action "Arrange $monitor_name ${position} $ref_monitor?"; then
		show_message "GREEN" "Arranging $monitor_name ${position} $ref_monitor"
		edit_command "${monitor_name}_arrangement" "$position $ref_monitor"
		show_message "GREEN" "Arrangement updated successfully."
		postrun_message="Arrangement of $monitor_name ${position} $ref_monitor updated successfully."
	else
		cancel_action
	fi
}

Set_scaling() {
    if [ "$MODE" = "pass" ];then
        for monitor in $monitor_array; do
            edit_command "${monitor}_scale" "--scale ${pass_arg}x${pass_arg}"
        done
        return
    fi
	postrun_title="Set Monitor Scaling Resolution"
	show_title "YELLOW" "Set Monitor Scaling Resolution"
	show_message "YELLOW" "Enter the new Scaling Resolution value as a percentage (10 to 300)"
	
	
	enter_choice "Enter the new Scaling Resolution value as a percentage (10 to 300):"
	picked_scaling_resolution="$choice"

	if [ -n "$picked_scaling_resolution" ];then
		new_scaling_resolution="$(awk "BEGIN {printf \"%.2f\", $picked_scaling_resolution / 100}")"
	else
		new_scaling_resolution="1"
	fi
	
	for monitor in $monitor_array; do
		show_message "CYAN" "Setting scaling for $monitor to ${picked_scaling_resolution} (resolution) ${new_scaling_resolution}x${new_scaling_resolution}"
		edit_command "${monitor}_scale" "--scale ${new_scaling_resolution}x${new_scaling_resolution}"
	done
	
	show_message "GREEN" "All monitor scalings have been set to ${picked_scaling_resolution}."
	postrun_message="All monitor scalings have been set to ${picked_scaling_resolution}."
}

disable_monitor() {
    if [ "$MODE" = "monitor" ];then
        edit_command "${picked_pass_monitor}_disable" "--off"
        return
    fi
	postrun_title="Disable Monitor"
	clear
	show_title "YELLOW" "Disable Monitor"
	if [ "$monitor_configuration" = "single" ];then
		monitor_name="$monitor_array"
	else
		show_message "YELLOW" "Choose a monitor to disable: "
		list_and_enter_choice "Enter the number of the monitor to disable:" "$monitor_choices"
		monitor_choice="$choice"
		
		if ! echo "$monitor_choice" | grep -qE '^[0-9]+$' || [ "$monitor_choice" -lt 1 ] || [ "$monitor_choice" -gt "$((i - 1))" ]; then
			Invalid_selection && return
		fi
		monitor_name=$(echo "$monitor_array" | cut -d' ' -f"$monitor_choice")
	fi
	show_message "RED" "Warning: Disabling the monitor will turn it off and may affect your display setup."
	
	if confirm_action "Auto-detect displays and set common resolution?"; then
		show_message "GREEN" "Disabling $monitor_name"
		edit_command "${monitor_name}_disable" "--off"
		show_message "GREEN" "Monitor $monitor_name disabled successfully."
		postrun_message="Monitor $monitor_name disabled successfully."
	else
		cancel_action
	fi
}

reset_monitor() {
    if [ "$MODE" = "monitor" ];then
        edit_command "${picked_pass_monitor}_resolution" "--auto"
        edit_command "${picked_pass_monitor}_primary" ""
        edit_command "${picked_pass_monitor}_enable" ""
        edit_command "${picked_pass_monitor}_extend" ""
        edit_command "${picked_pass_monitor}_brightness" ""
        edit_command "${picked_pass_monitor}_duplicate" ""
        edit_command "${picked_pass_monitor}_orientation" "--rotate normal"
        edit_command "${picked_pass_monitor}_arrangement" ""
        edit_command "${picked_pass_monitor}_scale" "--scale 1x1"
        edit_command "${picked_pass_monitor}_disable" ""
        return
    fi
	postrun_title="Disable Monitor"
	clear
	show_title "YELLOW" "Disable Monitor"
	if [ "$monitor_configuration" = "single" ];then
		monitor_name="$monitor_array"
	else
		show_message "YELLOW" "Choose a monitor to disable: "
		list_and_enter_choice "Enter the number of the monitor to disable:" "$monitor_choices"
		monitor_choice="$choice"
		
		if ! echo "$monitor_choice" | grep -qE '^[0-9]+$' || [ "$monitor_choice" -lt 1 ] || [ "$monitor_choice" -gt "$((i - 1))" ]; then
			Invalid_selection && return
		fi
		monitor_name=$(echo "$monitor_array" | cut -d' ' -f"$monitor_choice")
	fi
	show_message "RED" "Warning: Disabling the monitor will turn it off and may affect your display setup."
	
	if confirm_action "Auto-detect displays and set common resolution?"; then
		show_message "GREEN" "Disabling $monitor_name"
		edit_command "${monitor_name}_resolution" "--auto"
        edit_command "${monitor_name}_primary" ""
        edit_command "${monitor_name}_enable" ""
        edit_command "${monitor_name}_extend" ""
        edit_command "${monitor_name}_brightness" ""
        edit_command "${monitor_name}_duplicate" ""
        edit_command "${monitor_name}_orientation" "--rotate normal"
        edit_command "${monitor_name}_arrangement" ""
        edit_command "${monitor_name}_scale" "--scale 1x1"
        edit_command "${monitor_name}_disable" ""
		show_message "GREEN" "Monitor $monitor_name disabled successfully."
		postrun_message="Monitor $monitor_name disabled successfully."
	else
		cancel_action
	fi
}
##############################################################################################################################

help(){
	echo help
	exit
}

watch_for_device_hot_plugs(){
	__automate_it= true
	cooldown=4
	last_event_time=0
	
	udevadm monitor --subsystem-match=drm --udev | while read -r line; do
    	if echo "$line" | grep -q "change"; then
        	now=$(date +%s)
        	time_diff=$((now - last_event_time))
	
        	# If last event was more than cooldown seconds ago, print "changed"
        	if [ "$time_diff" -ge "$cooldown" ]; then
            	export XAUTHORITY="/home/$USER/.Xauthority"
            	export DISPLAY=:0
	        	sleep 1
	        	auto_detect_displays
            	last_event_time=$now
        	fi
    	fi
	done
}

monitor_list=$(detect_connected_monitors)
monitor_array=$(echo "$monitor_list" | tr '\n' ' ')
number_of_monitors=$(echo "$monitor_list" | wc -l)
monitor_choices=""

if [ "$number_of_monitors" -eq 1 ];then
	monitor_configuration="single"
	monitor_choices="1. $monitor_array"
else
	monitor_configuration="multi-monitor"
	i=1
	for monitor in $monitor_array; do
		monitor_choices="${monitor_choices}$i. $monitor|"
		i=$((i + 1))
	done
fi

if [ -z "$OPT__" ];then
	show_title "YELLOW" "Displays Options"
	main_choose="1. auto|2. Set_scaling|3. manage_arrangement|4. change_orientation|5. duplicate_displays|6. adjust_monitor_brightness|7. extend_displays|8. enable_monitor|9. set_primary_monitor|10. scale_monitors|11. disable_monitor|12. set_resolutions|13. Reset Monitor|14. Manual Selection|"
	list_and_enter_choice "displays options:" "$main_choose"
	OPT__="$(printf '%s' "$choice" | cut -d '.' -f 1)"
fi

case $OPT__ in
	0|watch) watch_for_device_hot_plugs ;;
	1|auto) auto_detect_displays ;;
	2|Set_scaling) Set_scaling ;;
	3|manage_arrangement) manage_arrangement ;;
	4|change_orientation) change_orientation ;;
	5|duplicate_displays) duplicate_displays ;;
	6|adjust_monitor_brightness) adjust_monitor_brightness ;;
	7|extend_displays) extend_displays ;;
	8|enable_monitor) enable_monitor ;;
	9|set_primary_monitor) set_primary_monitor ;;
	10|scale_monitors) scale_monitors ;;
	11|disable_monitor) disable_monitor ;;
	12|set_resolutions) set_resolutions ;;
	13|reset_monitor) reset_monitor ;;
    14|manual_selection) arandr ; exit ;;
	h|help) help ;;
	*) help
esac

execute_command "$display_script"
my_session_manager_cli reload
notification-d-session restart
notify_send_and_exit
