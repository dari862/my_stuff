#!/bin/bash
set -e
. "$__distro_path_lib"
. "${__distro_path_root}/lib/common/common"
. "${__distro_path_root}/lib/common/VM"

_SUPERUSER="my-superuser"

BIN_PATH="${__distro_path_neverremove}/bin"
APP_PATH="${__distro_path_neverremove}/applications"
TARGET_APPDATA_PATH="${__distro_path_neverremove}/winapps"

TEMP_PATH="$(mktemp -d /tmp/install_winapps_XXXXXX)"
TEMP_BIN_PATH="${TEMP_PATH}/bin"
TEMP_APP_PATH="${TEMP_PATH}/applications"
TEMP_TARGET_APPDATA_PATH="${TEMP_PATH}/winapps"

CONFIG_DIR_PATH_WITHOUT_HOME=".config/winapps"
CONFIG_DIR_PATH="${HOME}/${CONFIG_DIR_PATH_WITHOUT_HOME}"
CONFIG_PATH="${CONFIG_DIR_PATH}/winapps.conf"

USER_APPDATA_PATH="\${HOME}/.local/share/winapps"

# shellcheck disable=SC2034           # Silence warnings regarding unused variables globally.
EC_NO_CONFIG="4"        # Absence of a valid WinApps configuration file.
EC_MISSING_DEPS="5"     # Missing dependencies.
EC_NOT_IN_GROUP="7"     # Current user not in group 'libvirt' and/or 'kvm'.
EC_NO_IP="12"           # Windows does not have an IP address.
EC_BAD_PORT="13"        # Windows is unreachable via RDP_PORT.
EC_RDP_FAIL="14"        # FreeRDP failed to establish a connection with Windows.

BATCH_SCRIPT_PATH="${TEMP_PATH}/installed.bat"          # UNIX path to a batch script used to search Windows for applications.
TMP_INST_FILE_PATH="${TEMP_PATH}/installed.tmp"          # UNIX path to a temporary file containing the names of detected officially supported applications.
DETECTED_FILE_PATH="${TEMP_PATH}/detected"          # UNIX path to a file containing the output generated by the PowerShell script, formatted to define bash arrays.
TEST_PATH="${TEMP_PATH}/FreeRDP_Connection_Test"          # UNIX path to temporary file whose existence is used to confirm a successful RDP connection was established.
PS_SCRIPT_PATH="${TEMP_PATH}/ExtractPrograms.ps1"                          # UNIX path to a PowerShell script used to store the names, executable paths and icons (base64) of detected applications.

BATCH_SCRIPT_PATH_WIN="\\\\tsclient\\tmp\\$(basename "${BATCH_SCRIPT_PATH}")"
TMP_INST_FILE_PATH_WIN="\\\\tsclient\\tmp\\$(basename "${TMP_INST_FILE_PATH}")"
DETECTED_FILE_PATH_WIN="\\\\tsclient\\tmp\\$(basename "${DETECTED_FILE_PATH}")"
TEST_PATH_WIN="\\\\tsclient\\tmp\\$(basename "${TEST_PATH}")"
PS_SCRIPT_PATH_WIN="\\\\tsclient\\tmp\\$(basename "${PS_SCRIPT_PATH}")"

# REMOTE DESKTOP CONFIGURATION
RDP_PORT=3389         # Port used for RDP on Windows.

# WINAPPS CONFIGURATION FILE
RDP_USER="$username"
RDP_PASS="$passwd"
RDP_DOMAIN=""
RDP_IP=""
RDP_SCALE=100
RDP_FLAGS="/cert:tofu /sound /microphone +home-drive"
FREERDP_BIN="xfreerdp3"
REMOVABLE_MEDIA="/run/media"
DEBUG="true"
AUTOPAUSE="off"
AUTOPAUSE_TIME="300"
PORT_TIMEOUT=5
RDP_TIMEOUT=30
APP_SCAN_TIMEOUT=60
BOOT_TIMEOUT=120
HIDEF="on"

# INSTALLATION PROCESS
FREERDP_COMMAND=""

export LIBVIRT_DEFAULT_URI=qemu:///system

# Name: 'waFixScale'
# Role: Since FreeRDP only supports '/scale' values of 100, 140 or 180, find the closest supported argument to the user's configuration.
waFixScale() {
    # Define variables.
    OLD_SCALE=100
    VALID_SCALE_1=100
    VALID_SCALE_2=140
    VALID_SCALE_3=180

    # Check for an unsupported value.
    if [ "$RDP_SCALE" != "$VALID_SCALE_1" ] && [ "$RDP_SCALE" != "$VALID_SCALE_2" ] && [ "$RDP_SCALE" != "$VALID_SCALE_3" ]; then
        # Save the unsupported scale.
        OLD_SCALE="$RDP_SCALE"

        # Calculate the absolute differences.
        DIFF_1=$(( RDP_SCALE > VALID_SCALE_1 ? RDP_SCALE - VALID_SCALE_1 : VALID_SCALE_1 - RDP_SCALE ))
        DIFF_2=$(( RDP_SCALE > VALID_SCALE_2 ? RDP_SCALE - VALID_SCALE_2 : VALID_SCALE_2 - RDP_SCALE ))
        DIFF_3=$(( RDP_SCALE > VALID_SCALE_3 ? RDP_SCALE - VALID_SCALE_3 : VALID_SCALE_3 - RDP_SCALE ))

        # Set the final scale to the valid scale value with the smallest absolute difference.
        if (( DIFF_1 <= DIFF_2 && DIFF_1 <= DIFF_3 )); then
            RDP_SCALE="$VALID_SCALE_1"
        elif (( DIFF_2 <= DIFF_1 && DIFF_2 <= DIFF_3 )); then
            RDP_SCALE="$VALID_SCALE_2"
        else
            RDP_SCALE="$VALID_SCALE_3"
        fi

        # Print feedback.
        say "Unsupported RDP_SCALE value '${OLD_SCALE}' detected. Defaulting to '${RDP_SCALE}'." 'yellow'
    fi
}

# Name: 'waLoadConfig'
# Role: Loads settings specified within the WinApps configuration file.
waLoadConfig() {
    say "Waiting VM IP"
    while true;do
        VM_IP=$(virsh domifaddr "${VM_NAME}" | awk '/ipv4/ {print $4}' | head -n1 | cut -d/ -f1)
        if echo "$VM_IP" | grep -Eq '^(10\.|192\.168\.|172\.(1[6-9]|2[0-9]|3[0-1])\.)'; then
            break
        else
            sleep 60
        fi
    done
    RDP_IP="${VM_IP}"
    say " ✔  IP are : ${RDP_IP}"
    
    if [ ! -f "$CONFIG_PATH" ]; then
        say " Creating winapps.conf!"
        mkdir -p "$CONFIG_DIR_PATH"
        chmod 700 "$CONFIG_DIR_PATH"
		tee "$CONFIG_PATH" << EOF >/dev/null 2>&1
##################################
#   WINAPPS CONFIGURATION FILE   #
##################################

# INSTRUCTIONS
# - Leading and trailing whitespace are ignored.
# - Empty lines are ignored.
# - Lines starting with '#' are ignored.
# - All characters following a '#' are ignored.

# [WINDOWS USERNAME]
RDP_USER="$RDP_USER"

# [WINDOWS PASSWORD]
# NOTES:
# - If using FreeRDP v3.9.0 or greater, you *have* to set a password
RDP_PASS="$RDP_PASS"

# [WINDOWS DOMAIN]
# DEFAULT VALUE: '' (BLANK)
RDP_DOMAIN="${RDP_DOMAIN}"

# [WINDOWS IPV4 ADDRESS]
# NOTES:
# - If using 'libvirt', 'RDP_IP' will be determined by WinApps at runtime if left unspecified.
# DEFAULT VALUE:
# - 'docker': '127.0.0.1'
# - 'podman': '127.0.0.1'
# - 'libvirt': '' (BLANK)
RDP_IP="${RDP_IP}"

# [VM NAME]
# NOTES:
# - Only applicable when using 'libvirt'
# - The libvirt VM name must match so that WinApps can determine VM IP, start the VM, etc.
# DEFAULT VALUE: 'RDPWindows'
VM_NAME="${VM_NAME}"

# [DISPLAY SCALING FACTOR]
# NOTES:
# - If an unsupported value is specified, a warning will be displayed.
# - If an unsupported value is specified, WinApps will use the closest supported value.
# DEFAULT VALUE: '100'
# VALID VALUES:
# - '100'
# - '140'
# - '180'
RDP_SCALE="${RDP_SCALE}"

# [MOUNTING REMOVABLE PATHS FOR FILES]
# NOTES:
# - By default, \`udisks\` (which you most likely have installed) uses /run/media for mounting removable devices.
#   This improves compatibility with most desktop environments (DEs).
# ATTENTION: The Filesystem Hierarchy Standard (FHS) recommends /media instead. Verify your system's configuration.
# - To manually mount devices, you may optionally use /mnt.
# REFERENCE: https://wiki.archlinux.org/title/Udisks#Mount_to_/media
REMOVABLE_MEDIA="${REMOVABLE_MEDIA}"

# [ADDITIONAL FREERDP FLAGS & ARGUMENTS]
# NOTES:
# - You can try adding /network:lan to these flags in order to increase performance, however, some users have faced issues with this.
#   If this does not work or if it does not work without the flag, you can try adding /nsc and /gfx.
# DEFAULT VALUE: '/cert:tofu /sound /microphone +home-drive'
# VALID VALUES: See https://github.com/awakecoding/FreeRDP-Manuals/blob/master/User/FreeRDP-User-Manual.markdown
RDP_FLAGS="${RDP_FLAGS}"

# [DEBUG WINAPPS]
# NOTES:
# - Creates and appends to ~/.local/share/winapps/winapps.log when running WinApps.
# DEFAULT VALUE: 'true'
# VALID VALUES:
# - 'true'
# - 'false'
DEBUG="${DEBUG}"

# [AUTOMATICALLY PAUSE WINDOWS]
# NOTES:
# - This is currently INCOMPATIBLE with 'manual'.
# DEFAULT VALUE: 'off'
# VALID VALUES:
# - 'on'
# - 'off'
AUTOPAUSE="${AUTOPAUSE}"

# [AUTOMATICALLY PAUSE WINDOWS TIMEOUT]
# NOTES:
# - This setting determines the duration of inactivity to tolerate before Windows is automatically paused.
# - This setting is ignored if 'AUTOPAUSE' is set to 'off'.
# - The value must be specified in seconds (to the nearest 10 seconds e.g., '30', '40', '50', etc.).
# - For RemoteApp RDP sessions, there is a mandatory 20-second delay, so the minimum value that can be specified here is '20'.
# - Source: https://techcommunity.microsoft.com/t5/security-compliance-and-identity/terminal-services-remoteapp-8482-session-termination-logic/ba-p/246566
# DEFAULT VALUE: '300'
# VALID VALUES: >=20
AUTOPAUSE_TIME="${AUTOPAUSE_TIME}"

# [FREERDP BIN]
# NOTES:
# - WinApps will attempt to automatically detect the correct command to use for your system.
# DEFAULT VALUE: '' (BLANK)
# VALID VALUES: The command required to run FreeRDPv3 on your system (e.g., 'xfreerdp', 'xfreerdp3', etc.).
FREERDP_BIN="${FREERDP_BIN}"

# [TIMEOUTS]
# NOTES:
# - These settings control various timeout durations within the WinApps setup.
# - Increasing the timeouts is only necessary if the corresponding errors occur.
# - Ensure you have followed all the Troubleshooting Tips in the error message first.

# PORT CHECK
# - The maximum time (in seconds) to wait when checking if the RDP port on Windows is open.
# - Corresponding error: "NETWORK CONFIGURATION ERROR" (exit status 13).
# DEFAULT VALUE: '5'
PORT_TIMEOUT="${PORT_TIMEOUT}"

# RDP CONNECTION TEST
# - The maximum time (in seconds) to wait when testing the initial RDP connection to Windows.
# - Corresponding error: "REMOTE DESKTOP PROTOCOL FAILURE" (exit status 14).
# DEFAULT VALUE: '30'
RDP_TIMEOUT="${RDP_TIMEOUT}"

# APPLICATION SCAN
# - The maximum time (in seconds) to wait for the script that scans for installed applications on Windows to complete.
# - Corresponding error: "APPLICATION QUERY FAILURE" (exit status 15).
# DEFAULT VALUE: '60'
APP_SCAN_TIMEOUT="${APP_SCAN_TIMEOUT}"

# WINDOWS BOOT
# - The maximum time (in seconds) to wait for the Windows VM to boot if it is not running, before attempting to launch an application.
# DEFAULT VALUE: '120'
BOOT_TIMEOUT="${BOOT_TIMEOUT}"

# FREERDP RAIL HIDEF
# - This option controls the value of the \`hidef\` option passed to the /app parameter of the FreeRDP command.
# - Setting this option to 'off' may resolve window misalignment issues related to maximized windows.
# DEFAULT VALUE: 'on'
HIDEF="${HIDEF}"
EOF
        chmod 600 "$CONFIG_PATH"
        say " ✔  Done creating winapps.conf" 'green'
    else
        sed -i "s/^RDP_IP=.*/RDP_IP=${VM_IP}/g" "$CONFIG_PATH"
        sed -i "s/^VM_NAME=.*/VM_NAME=${VM_NAME}/g" "$CONFIG_PATH"
    fi

    say "Attempting to load WinApps configuration file... " 'yellow'
    source "$CONFIG_PATH"
    
    # Print feedback.
    say "Done!" 'green'
}

# Name: 'waCheckScriptDependencies'
# Role: Terminate script if dependencies are missing.
waCheckScriptDependencies() {
    exit_now=false
    FREERDP_MAJOR_VERSION=""

    if ! command -v notify-send &>/dev/null; then
        say "Please install 'libnotify' to proceed." 'red'
        exit_now=true
    fi

    if command -v xfreerdp &>/dev/null; then
        FREERDP_BIN=xfreerdp
    elif command -v xfreerdp3 &>/dev/null; then
        FREERDP_BIN=xfreerdp3
    else
        say "Please install 'FreeRDP' version 3 to proceed." 'red'
        exit_now=true
    fi
    
    if [[ -n "$FREERDP_BIN" ]]; then
        FREERDP_MAJOR_VERSION="$(${FREERDP_BIN} --version | head -n 1 | grep -o -m 1 '\b[0-9]\S*' | head -n 1 | cut -d'.' -f1)"
        if [[ $FREERDP_MAJOR_VERSION =~ ^[0-9]+$ ]] && ((FREERDP_MAJOR_VERSION >= 3)); then
            FREERDP_BIN="${FREERDP_BIN}"
        else
            exit_now=true
        fi
    fi

    if ! command -v virsh &>/dev/null; then
        say "Please install 'Virtual Machine Manager' to proceed." 'red'
        exit_now=true
    fi

    if ! command -v ip &>/dev/null; then
        say "Please install 'iproute2' to proceed." 'red'
        exit_now=true
    fi
    
    if [ "$exit_now" = true ];then
        exit 1
    fi
}

# Name: 'waCheckGroupMembership'
# Role: Ensures the current user is part of the required groups.
waCheckVMRunning() {
    # Print feedback.
    say "Checking whether the user '$(whoami)' is part of the required groups... "

    # Declare variables.
    USER_GROUPS="" # Stores groups the current user belongs to.

    # Identify groups the current user belongs to.
    USER_GROUPS=$(groups "$(whoami)")

    if ! (echo "$USER_GROUPS" | grep -q -E "\blibvirt\b") || ! (echo "$USER_GROUPS" | grep -q -E "\bkvm\b"); then
        say "--------------------------------------------------------------------------------" 'red'
        say "Please run the below commands, followed by a system reboot:" 'red'
        say "usermod -a -G libvirt $(whoami)" 'yellow'
        say "usermod -a -G kvm $(whoami)" 'yellow'
        say "--------------------------------------------------------------------------------" 'red'
        exit 1
    fi

    if virsh list --state-shutoff --name | grep -Fxq -- "$VM_NAME"; then
        virsh start ${VM_NAME} || exit 1
    elif virsh list --state-paused --name | grep -Fxq -- "$VM_NAME"; then
        virsh resume ${VM_NAME} || exit 1
    elif ! virsh list --state-running --name | grep -Fxq -- "$VM_NAME"; then
        say "The Windows VM '${VM_NAME}' could not be found." 'red'
        exit 1
    fi
}

waCheckRDPAccess() {
    # Print feedback.
    say "Checking for an open RDP Port on Windows... "

    # Declare variables.
    VM_MAC="" # Stores the MAC address of the Windows VM.

    # Obtain Windows VM IP Address (FOR 'libvirt' ONLY)
    # Note: 'RDP_IP' should not be empty, since it is set to localhost before this is called.
    if [ -z "$RDP_IP" ]; then
        VM_MAC=$(virsh domiflist "$VM_NAME" | grep -oE "([0-9A-Fa-f]{2}[:-]){5}([0-9A-Fa-f]{2})") # VM MAC address.
        RDP_IP=$(ip neigh show | grep "$VM_MAC" | grep -oE "([0-9]{1,3}\.){3}[0-9]{1,3}")         # VM IP address.

        if [ -z "$RDP_IP" ]; then
            say "Failed!" 'red'
            say "ERROR: NETWORK CONFIGURATION ERROR." 'red'
            say "The IP address of the Windows VM '${VM_NAME}' could not be found." 'red'
            say "--------------------------------------------------------------------------------" 'red'
            say "Please ensure networking is properly configured for the Windows VM." 'red'
            say "--------------------------------------------------------------------------------" 'red'
            exit 1
        fi
    fi
    
    if ! timeout "$PORT_TIMEOUT" bash -c "</dev/tcp/$RDP_IP/$RDP_PORT" >/dev/null 2>&1; then
        say "Failed!" 'yellow'
        say "ERROR: NETWORK CONFIGURATION ERROR." 'yellow'
        say "Failed to establish a connection with Windows at '${RDP_IP}:${RDP_PORT}'." 'yellow'
        sleep 5
        if ! timeout "$PORT_TIMEOUT" bash -c "</dev/tcp/$RDP_IP/$RDP_PORT" >/dev/null 2>&1; then
            say "--------------------------------------------------------------------------------"
            say "Please ensure Remote Desktop is configured on Windows as per the WinApps README." 'yellow'
            say "Then you can try increasing the PORT_TIMEOUT in ${CONFIG_PATH} ." 'red'
            say "--------------------------------------------------------------------------------" 'yellow'
            while true;do
                if ! timeout "$PORT_TIMEOUT" bash -c "</dev/tcp/$RDP_IP/$RDP_PORT" >/dev/null 2>&1;then
                    say "Failed to establish a connection with Windows at '${RDP_IP}:${RDP_PORT}'." 'yellow'
                    sleep 5
                else
                    say "Connection to Windows RDP Port was successful... " 'green'
                    break
                fi
            done
        else
            say "Connection to Windows RDP Port was successful... " 'green'
        fi
    fi
    
    say "Attempting to establish a Remote Desktop connection with Windows... "
    FREERDP_LOG=""  # Stores the path of the FreeRDP log file.
    FREERDP_PROC="" # Stores the FreeRDP process ID.
    ELAPSED_TIME="" # Stores the time counter.
    FREERDP_LOG="${TEMP_PATH}/FreeRDP_Test_$(date +'%Y%m%d_%H%M_%N').log"
    rm -f "$TEST_PATH"
    $FREERDP_COMMAND \
        /cert:ignore \
        /u:"$RDP_USER" \
        /p:"$RDP_PASS" \
        /scale:"$RDP_SCALE" \
        +auto-reconnect \
        /drive:tmp,${TEMP_PATH} \
        /app:program:"C:\Windows\System32\cmd.exe",cmd:"/C type NUL > $TEST_PATH_WIN && tsdiscon" \
        /v:"$RDP_IP" &>"$FREERDP_LOG" &
    FREERDP_PROC=$!
    ELAPSED_TIME=0
    while [ "$ELAPSED_TIME" -lt "$RDP_TIMEOUT" ]; do
        if ! ps -p "$FREERDP_PROC" &>/dev/null || [ -f "$TEST_PATH" ]; then
            break
        fi
        sleep 5
        ELAPSED_TIME=$((ELAPSED_TIME + 5))
    done
    if ps -p "$FREERDP_PROC" &>/dev/null; then
        kill -9 "$FREERDP_PROC" &>/dev/null
    fi
    if ! [ -f "$TEST_PATH" ]; then
        say "Failed!" 'red'
        say "ERROR: REMOTE DESKTOP PROTOCOL FAILURE." 'red'
        say "FreeRDP failed to establish a connection with Windows." 'red'
        say "--------------------------------------------------------------------------------"
        say "Please view the log at ${FREERDP_LOG}." 'red'
        say "Troubleshooting Tips:" 'red'
        say "  - Ensure the user is logged out of Windows prior to initiating the WinApps installation." 'red'
        say "  - Ensure the credentials within the WinApps configuration file are correct." 'red'
        say "  - Utilise a new certificate by removing relevant certificate(s) in ${HOME}/.config/freerdp/server." 'red'
        say "  - Try increasing the RDP_TIMEOUT in ${CONFIG_PATH}." 'red'
        say "  - If using 'libvirt', ensure the Windows VM is correctly named as specified within the README." 'red'
        say "  - If using 'libvirt', ensure 'Remote Desktop' is enabled within the Windows VM." 'red'
        say "  - If using 'libvirt', ensure you have merged 'RDPApps.reg' into the Windows VM's registry." 'red'
        say "  - If using 'libvirt', try logging into and back out of the Windows VM within 'virt-manager' prior to initiating the WinApps installation." 'red'
        say "--------------------------------------------------------------------------------"
        exit 1
    else
        rm -f "$TEST_PATH"
    fi
    say "Done!" 'green'
}

waConfigureWindows() {
    say "Creating an application entry for Windows... "

    WIN_BASH=""    # Stores the bash script to launch a Windows RDP session.
    WIN_DESKTOP="" # Stores the '.desktop' file to launch a Windows RDP session.

    WIN_BASH="\
#!/usr/bin/env bash
${BIN_PATH}/winapps windows"
    WIN_DESKTOP="\
[Desktop Entry]
Name=Windows
Exec=${BIN_PATH}/winapps windows %F
Terminal=false
Type=Application
Icon=${TARGET_APPDATA_PATH}/icons/windows.svg
StartupWMClass=Microsoft Windows
Comment=Microsoft Windows RDP Session"

    echo "$WIN_DESKTOP" | tee "${TEMP_APP_PATH}/windows.desktop" &>/dev/null
    echo "$WIN_BASH" | tee "${TEMP_BIN_PATH}/windows" &>/dev/null
    chmod a+x "${TEMP_BIN_PATH}/windows"
    echo "${DONE_TEXT}Done!"
}

waConfigureApp() {
    APP_ICON=""         # Stores the path to the application icon.
    APP_BASH=""         # Stores the bash script used to launch the application.
    APP_DESKTOP_FILE="" # Stores the '.desktop' file used to launch the application.
    source "${TEMP_TARGET_APPDATA_PATH}/apps/${1}/info"
    APP_ICON="${TARGET_APPDATA_PATH}/apps/${1}/icon.svg"
    APP_BASH="\
#!/usr/bin/env bash
${BIN_PATH}/winapps ${1}"
    APP_DESKTOP_FILE="\
[Desktop Entry]
Name=${FULL_NAME}
Exec=${BIN_PATH}/winapps ${1} %F
Terminal=false
Type=Application
Icon=${APP_ICON}
StartupWMClass=${FULL_NAME}
Comment=${FULL_NAME}
Categories=${CATEGORIES}
MimeType=${MIME_TYPES}"
    echo "$APP_DESKTOP_FILE" | tee "${TEMP_APP_PATH}/${1}.desktop" &>/dev/null
    echo "$APP_BASH" | tee "${TEMP_BIN_PATH}/${1}" &>/dev/null
    chmod a+x "${TEMP_BIN_PATH}/${1}"
}

waConfigureOfficiallySupported() {
    say "Checking for installed Windows applications... "
    FREERDP_LOG=""  # Stores the path of the FreeRDP log file.
    FREERDP_PROC="" # Stores the FreeRDP process ID.
    ELAPSED_TIME="" # Stores the time counter.
    FREERDP_LOG="${TEMP_PATH}/FreeRDP_Scan_$(date +'%Y%m%d_%H%M_%N').log"
    rm -f "$BATCH_SCRIPT_PATH" "$TMP_INST_FILE_PATH" "$INST_FILE_PATH" "$DETECTED_FILE_PATH"
    echo "powershell.exe -ExecutionPolicy Bypass -File ${PS_SCRIPT_PATH_WIN} > ${DETECTED_FILE_PATH_WIN}" >>"$BATCH_SCRIPT_PATH"
    echo "RENAME ${TMP_INST_FILE_PATH_WIN} installed" >>"$BATCH_SCRIPT_PATH"
    echo "tsdiscon" >>"$BATCH_SCRIPT_PATH"
    $FREERDP_COMMAND \
        /cert:ignore \
        /u:"$RDP_USER" \
        /p:"$RDP_PASS" \
        /scale:"$RDP_SCALE" \
        +auto-reconnect \
        /drive:tmp,${TEMP_PATH} \
        /app:program:"C:\Windows\System32\cmd.exe",cmd:"/C "$BATCH_SCRIPT_PATH_WIN"" \
        /v:"$RDP_IP" &>"$FREERDP_LOG" &
    FREERDP_PROC=$!
    ELAPSED_TIME=0
    while [ $ELAPSED_TIME -lt "$APP_SCAN_TIMEOUT" ]; do
        if ! ps -p "$FREERDP_PROC" &>/dev/null; then
            break
        fi
        sleep 5
        ELAPSED_TIME=$((ELAPSED_TIME + 5))
    done
    if ps -p "$FREERDP_PROC" &>/dev/null; then
        kill -9 "$FREERDP_PROC" &>/dev/null
    fi

    sed -i 's/\r$//' "${DETECTED_FILE_PATH}"
    source "$DETECTED_FILE_PATH"

    length_of_arrays="$((${#NAMES[@]} - 1 ))"
    for (( index=0; index<=length_of_arrays; index++ )); do
        FULL_NAME="${NAMES[$index]}"
        WIN_EXECUTABLE="${EXES[$index]}"
        base64_ICON="${ICONS[$index]}"
        
        appNAME=$(echo "$WIN_EXECUTABLE" | awk -F'\' '{print $NF}')
        appNAME=$(echo "$appNAME" | sed 's/.exe//g' || echo "$appNAME" | sed 's/.EXE//g')
        mkdir -p "${TEMP_TARGET_APPDATA_PATH}/apps/$appNAME"
tee "${TEMP_TARGET_APPDATA_PATH}/apps/$appNAME/info" << EOF > /dev/null 2>&1
NAME="${appNAME}"
FULL_NAME="${FULL_NAME}"
WIN_EXECUTABLE="${WIN_EXECUTABLE}"
CATEGORIES="WinApps;Windows"
MIME_TYPES="${TARGET_APPDATA_PATH}/apps/$appNAME/icon.svg"
EOF
        echo "$base64_ICON" | base64 --decode | tee "${TEMP_TARGET_APPDATA_PATH}/apps/$appNAME/icon.svg" >/dev/null 2>&1
    done
    
    cd "${TEMP_TARGET_APPDATA_PATH}/apps"
    
    for OSA in *; do
        APP_NAME="$(basename "$OSA")"
        waConfigureApp "$APP_NAME" 
    done
}

waInstall() {
    say "Installing WinApps."
    waCheckVMRunning
    waLoadConfig
    waFixScale
    
    if [[ -n $RDP_FLAGS ]]; then
        FREERDP_COMMAND="${FREERDP_COMMAND} ${RDP_FLAGS}"
    fi
    
    FREERDP_COMMAND="${FREERDP_BIN} ${FREERDP_COMMAND}"

    waCheckRDPAccess
    waConfigureWindows
    waConfigureOfficiallySupported
    waEnsureOnPath
}

waEnsureOnPath() {
    if [[ ":$PATH:" != *":$BIN_PATH:"* ]]; then
        say "[WARNING] It seems like '${BIN_PATH}' is not on PATH." 'yellow'
        say "[WARNING] You can add it by running:" 'yellow'
        say "[WARNING]   - For Bash: echo 'export PATH="${BIN_PATH}:\$PATH"' >> ~/.bashrc && source ~/.bashrc" 'yellow'
        say "[WARNING]   - For ZSH: echo 'export PATH="${BIN_PATH}:\$PATH"' >> ~/.zshrc && source ~/.zshrc" 'yellow'
        say "[WARNING] Make sure to restart your Terminal afterwards.\n" 'yellow'
    fi
}

Create_winapps_script() {
    tee "${TEMP_BIN_PATH}/winapps" << EOF > /dev/null 2>&1
#!/usr/bin/env bash
export LIBVIRT_DEFAULT_URI=qemu:///system

### GLOBAL CONSTANTS ###
# ERROR CODES
readonly EC_MISSING_CONFIG=1
readonly EC_MISSING_FREERDP=2
readonly EC_NOT_IN_GROUP=3
readonly EC_FAIL_START=4
readonly EC_FAIL_RESUME=5
readonly EC_FAIL_DESTROY=6
readonly EC_SD_TIMEOUT=7
readonly EC_DIE_TIMEOUT=8
readonly EC_RESTART_TIMEOUT=9
readonly EC_NOT_EXIST=10
readonly EC_UNKNOWN=11
readonly EC_NO_IP=12
readonly EC_BAD_PORT=13
readonly EC_UNSUPPORTED_APP=14
readonly EC_INVALID_FLAVOR=15

# PATHS
readonly CONFIG_DIR_PATH="\${HOME}/${CONFIG_DIR_PATH_WITHOUT_HOME}"
readonly CONFIG_PATH="\${CONFIG_DIR_PATH}/winapps.conf"
readonly TARGET_APPDATA_PATH="${TARGET_APPDATA_PATH}"
readonly USER_APPDATA_PATH="${USER_APPDATA_PATH}"
readonly LASTRUN_PATH="\${USER_APPDATA_PATH}/lastrun"
readonly LOG_PATH="\${USER_APPDATA_PATH}/winapps.log"

readonly SLEEP_DETECT_PATH="\${USER_APPDATA_PATH}/last_activity"
readonly SLEEP_MARKER="\${USER_APPDATA_PATH}/sleep_marker"

# OTHER
readonly RDP_PORT=${RDP_PORT}
# shellcheck disable=SC2155 # Silence warnings regarding masking return values through simultaneous declaration and assignment.
readonly RUNID="\${RANDOM}"

### GLOBAL VARIABLES ###
# WINAPPS CONFIGURATION FILE
VM_NAME="${VM_NAME}"
RDP_USER="${RDP_USER}"
RDP_PASS="${RDP_PASS}"
RDP_DOMAIN="${RDP_DOMAIN}"
RDP_IP="${RDP_IP}"
RDP_SCALE="${RDP_SCALE}"
RDP_FLAGS="${RDP_FLAGS}"
FREERDP_BIN="${FREERDP_BIN}"
REMOVABLE_MEDIA="${REMOVABLE_MEDIA}"
DEBUG="${DEBUG}"
AUTOPAUSE="${AUTOPAUSE}"
AUTOPAUSE_TIME="${AUTOPAUSE_TIME}"
PORT_TIMEOUT=${PORT_TIMEOUT}
RDP_TIMEOUT=${RDP_TIMEOUT}
APP_SCAN_TIMEOUT=${APP_SCAN_TIMEOUT}
BOOT_TIMEOUT=${BOOT_TIMEOUT}
HIDEF="${HIDEF}"

# OTHER
FREERDP_PID=-1
NEEDED_BOOT=false

FREERDP_COMMAND=""

### TRAPS ###
# Catch SIGINT (CTRL+C) to call 'waCleanUp'.
trap waCleanUp SIGINT

### FUNCTIONS ###
# Name: 'waCleanUp'
# Role: Clean up remains prior to exit.
waCleanUp() {
    # Kill FreeRDP.
    [ "\$FREERDP_PID" -gt 0 ] && kill -9 "\$FREERDP_PID" >/dev/null 2>&1

    # Remove '.cproc' file.
    [ -f "\${USER_APPDATA_PATH}/FreeRDP_Process_\${FREERDP_PID}.cproc" ] && rm "\${USER_APPDATA_PATH}/FreeRDP_Process_\${FREERDP_PID}.cproc" >/dev/null 2>&1

    # Terminate script.
    exit 1
}

send_notification_error(){
	local expire_time="\${1:-8000}"
	local notification_massage="\${2:-}"
	notify-send --expire-time=\${expire_time} --icon="dialog-error" --app-name="WinApps" --urgency="low" "WinApps" "\${notification_massage}"
}

send_notification_info(){
	local expire_time="\${1:-4000}"
	local notification_massage="\${2:-}"
	notify-send --expire-time=\${expire_time} --icon="dialog-info" --app-name="WinApps" --urgency="low" "WinApps" "\${notification_massage}"
}

send_notification_other(){
	local expire_time="\${1:-8000}"
	local custom_icon="\${2:-info}"
	local notification_massage="\${3:-}"
	notify-send --expire-time=\${expire_time} --icon="\${custom_icon}" --app-name="WinApps" --urgency="low" "WinApps" "\${notification_massage}"
}

# Name: 'waThrowExit'
# Role: Throw an error message and exit the script.
function waThrowExit() {
    # Declare variables.
    local ERR_CODE="\$1"

    # Throw error.
    case "\$ERR_CODE" in
    "\$EC_MISSING_CONFIG")
        # Missing WinApps configuration file.
        dprint "ERROR: MISSING WINAPPS CONFIGURATION FILE. EXITING."
        send_notification_error "8000" "The WinApps configuration file is missing.\nPlease create a WinApps configuration file at '\${CONFIG_PATH}'."
        ;;
    "\$EC_MISSING_FREERDP")
        dprint "ERROR: FREERDP VERSION 3 IS NOT INSTALLED. EXITING."
        send_notification_error "8000" "FreeRDP version 3 is not installed."
        ;;
    "\$EC_NOT_IN_GROUP")
        dprint "ERROR: USER NOT PART OF REQUIRED GROUPS. EXITING."
        send_notification_error "8000" "The user \$(whoami) is not part of the required groups.
Please run:
    sudo usermod -a -G libvirt \$(whoami)
    sudo usermod -a -G kvm \$(whoami)"
        ;;
    "\$EC_FAIL_START")
        dprint "ERROR: WINDOWS FAILED TO START. EXITING."
        send_notification_error "8000" "Windows failed to start."
        ;;
    "\$EC_FAIL_RESUME")
        dprint "ERROR: WINDOWS FAILED TO RESUME. EXITING."
        send_notification_error "8000" "Windows failed to resume."
        ;;
    "\$EC_FAIL_DESTROY")
        dprint "ERROR: FAILED TO FORCE STOP WINDOWS. EXITING."
        send_notification_error "8000" "Failed to forcibly stop Windows."
        ;;
    "\$EC_SD_TIMEOUT")
        dprint "ERROR: WINDOWS TOOK TOO LONG TO SHUT DOWN. EXITING."
        send_notification_error "8000" "Windows took too long to shut down."
        ;;
    "\$EC_DIE_TIMEOUT")
        dprint "ERROR: WINDOWS TOOK TOO LONG TO DIE. EXITING."
        send_notification_error "8000" "Windows took too long to die."
        ;;
    "\$EC_RESTART_TIMEOUT")
        dprint "ERROR: WINDOWS TOOK TOO LONG TO RESTART. EXITING."
        send_notification_error "8000" "Windows took too long to restart."
        ;;
    "\$EC_NOT_EXIST")
        dprint "ERROR: WINDOWS NONEXISTENT. EXITING."
        send_notification_error "8000" "Windows VM named '\${VM_NAME}' does not exist."
        ;;
    "\$EC_UNKNOWN")
        dprint "ERROR: UNKNOWN CONTAINER ERROR. EXITING."
        send_notification_error "8000" "Unknown Windows container error."
        ;;
    "\$EC_NO_IP")
        dprint "ERROR: WINDOWS UNREACHABLE. EXITING."
        send_notification_error "8000" "Windows is unreachable.\nPlease ensure Windows is assigned an IP address."
        ;;
    "\$EC_BAD_PORT")
        dprint "ERROR: RDP PORT CLOSED. EXITING."
        send_notification_error "8000" "The Windows RDP port '\${RDP_PORT}' is closed.\nPlease ensure Remote Desktop is correctly configured on Windows."
        ;;
    "\$EC_UNSUPPORTED_APP")
        dprint "ERROR: APPLICATION NOT FOUND. EXITING."
        send_notification_error "8000" "Application not found.\nPlease ensure the program is correctly configured as an officially supported application."
        ;;
    "\$EC_INVALID_FLAVOR")
        dprint "ERROR: INVALID FLAVOR. EXITING."
        send_notification_error "8000" "Invalid WinApps flavor.\nPlease ensure 'docker', 'podman' or 'libvirt' are specified as the flavor in the WinApps configuration file."
        ;;
    esac

    # Terminate the script.
    exit "\$ERR_CODE"
}

# Name: 'dprint'
# Role: Conditionally print debug messages to a log file, creating it if it does not exist.
function dprint() {
    [ "\$DEBUG" = "true" ] && echo "[\$(date)-\$RUNID] \$1" >>"\$LOG_PATH"
}
# Name: 'waFixRemovableMedia'
# Role: If REMOVABLE_MEDIA is empty, default to /run/media (udisks default) and show a warning.
function waFixRemovableMedia() {
    if [ -z "\$REMOVABLE_MEDIA" ]; then
        REMOVABLE_MEDIA="/run/media"  # Default for udisks
        dprint "NOTICE: Using default REMOVABLE_MEDIA: \$REMOVABLE_MEDIA"
        send_notification_other "3000" "drive-removable-media" "Using default removable media path: \$REMOVABLE_MEDIA"
    fi
}
# Name: 'waFixScale'
# Role: Since FreeRDP only supports '/scale' values of 100, 140 or 180, find the closest supported argument to the user's configuration.
function waFixScale() {
    # Define variables.
    local OLD_SCALE=100
    local VALID_SCALE_1=100
    local VALID_SCALE_2=140
    local VALID_SCALE_3=180

    # Check for an unsupported value.
    if [ "\$RDP_SCALE" != "\$VALID_SCALE_1" ] && [ "\$RDP_SCALE" != "\$VALID_SCALE_2" ] && [ "\$RDP_SCALE" != "\$VALID_SCALE_3" ]; then
        # Save the unsupported scale.
        OLD_SCALE="\$RDP_SCALE"

        # Calculate the absolute differences.
        local DIFF_1=\$(( RDP_SCALE > VALID_SCALE_1 ? RDP_SCALE - VALID_SCALE_1 : VALID_SCALE_1 - RDP_SCALE ))
        local DIFF_2=\$(( RDP_SCALE > VALID_SCALE_2 ? RDP_SCALE - VALID_SCALE_2 : VALID_SCALE_2 - RDP_SCALE ))
        local DIFF_3=\$(( RDP_SCALE > VALID_SCALE_3 ? RDP_SCALE - VALID_SCALE_3 : VALID_SCALE_3 - RDP_SCALE ))

        # Set the final scale to the valid scale value with the smallest absolute difference.
        if (( DIFF_1 <= DIFF_2 && DIFF_1 <= DIFF_3 )); then
            RDP_SCALE="\$VALID_SCALE_1"
        elif (( DIFF_2 <= DIFF_1 && DIFF_2 <= DIFF_3 )); then
            RDP_SCALE="\$VALID_SCALE_2"
        else
            RDP_SCALE="\$VALID_SCALE_3"
        fi

        # Print feedback.
        dprint "WARNING: Unsupported RDP_SCALE value '\${OLD_SCALE}'. Defaulting to '\${RDP_SCALE}'."
        send_notification_error "4000" "Unsupported RDP_SCALE value '\${OLD_SCALE}'.\nDefaulting to '\${RDP_SCALE}'."
    fi
}

# Name: 'waLoadConfig'
# Role: Load the variables within the WinApps configuration file.
function waLoadConfig() {
    # Load WinApps configuration file.
    if [ ! -f "\$CONFIG_PATH" ]; then
        mkdir -p "$CONFIG_DIR_PATH"
        chmod 700 "$CONFIG_DIR_PATH"
		tee "$CONFIG_PATH" << EOFCONF >/dev/null 2>&1
##################################
#   WINAPPS CONFIGURATION FILE   #
##################################

# INSTRUCTIONS
# - Leading and trailing whitespace are ignored.
# - Empty lines are ignored.
# - Lines starting with '#' are ignored.
# - All characters following a '#' are ignored.

# [WINDOWS USERNAME]
RDP_USER="\$RDP_USER"

# [WINDOWS PASSWORD]
# NOTES:
# - If using FreeRDP v3.9.0 or greater, you *have* to set a password
RDP_PASS="\$RDP_PASS"

# [WINDOWS DOMAIN]
# DEFAULT VALUE: '' (BLANK)
RDP_DOMAIN="\${RDP_DOMAIN}"

# [WINDOWS IPV4 ADDRESS]
# NOTES:
# - If using 'libvirt', 'RDP_IP' will be determined by WinApps at runtime if left unspecified.
# DEFAULT VALUE:
# - 'docker': '127.0.0.1'
# - 'podman': '127.0.0.1'
# - 'libvirt': '' (BLANK)
RDP_IP="\${RDP_IP}"

# [VM NAME]
# NOTES:
# - Only applicable when using 'libvirt'
# - The libvirt VM name must match so that WinApps can determine VM IP, start the VM, etc.
# DEFAULT VALUE: 'RDPWindows'
VM_NAME="\${VM_NAME}"

# [DISPLAY SCALING FACTOR]
# NOTES:
# - If an unsupported value is specified, a warning will be displayed.
# - If an unsupported value is specified, WinApps will use the closest supported value.
# DEFAULT VALUE: '100'
# VALID VALUES:
# - '100'
# - '140'
# - '180'
RDP_SCALE="\${RDP_SCALE}"

# [MOUNTING REMOVABLE PATHS FOR FILES]
# NOTES:
# - By default, \`udisks\` (which you most likely have installed) uses /run/media for mounting removable devices.
#   This improves compatibility with most desktop environments (DEs).
# ATTENTION: The Filesystem Hierarchy Standard (FHS) recommends /media instead. Verify your system's configuration.
# - To manually mount devices, you may optionally use /mnt.
# REFERENCE: https://wiki.archlinux.org/title/Udisks#Mount_to_/media
REMOVABLE_MEDIA="\${REMOVABLE_MEDIA}"

# [ADDITIONAL FREERDP FLAGS & ARGUMENTS]
# NOTES:
# - You can try adding /network:lan to these flags in order to increase performance, however, some users have faced issues with this.
#   If this does not work or if it does not work without the flag, you can try adding /nsc and /gfx.
# DEFAULT VALUE: '/cert:tofu /sound /microphone +home-drive'
# VALID VALUES: See https://github.com/awakecoding/FreeRDP-Manuals/blob/master/User/FreeRDP-User-Manual.markdown
RDP_FLAGS="\${RDP_FLAGS}"

# [DEBUG WINAPPS]
# NOTES:
# - Creates and appends to ~/.local/share/winapps/winapps.log when running WinApps.
# DEFAULT VALUE: 'true'
# VALID VALUES:
# - 'true'
# - 'false'
DEBUG="\${DEBUG}"

# [AUTOMATICALLY PAUSE WINDOWS]
# NOTES:
# - This is currently INCOMPATIBLE with 'manual'.
# DEFAULT VALUE: 'off'
# VALID VALUES:
# - 'on'
# - 'off'
AUTOPAUSE="\${AUTOPAUSE}"

# [AUTOMATICALLY PAUSE WINDOWS TIMEOUT]
# NOTES:
# - This setting determines the duration of inactivity to tolerate before Windows is automatically paused.
# - This setting is ignored if 'AUTOPAUSE' is set to 'off'.
# - The value must be specified in seconds (to the nearest 10 seconds e.g., '30', '40', '50', etc.).
# - For RemoteApp RDP sessions, there is a mandatory 20-second delay, so the minimum value that can be specified here is '20'.
# - Source: https://techcommunity.microsoft.com/t5/security-compliance-and-identity/terminal-services-remoteapp-8482-session-termination-logic/ba-p/246566
# DEFAULT VALUE: '300'
# VALID VALUES: >=20
AUTOPAUSE_TIME="\${AUTOPAUSE_TIME}"

# [FREERDP BIN]
# NOTES:
# - WinApps will attempt to automatically detect the correct command to use for your system.
# DEFAULT VALUE: '' (BLANK)
# VALID VALUES: The command required to run FreeRDPv3 on your system (e.g., 'xfreerdp', 'xfreerdp3', etc.).
FREERDP_BIN="\${FREERDP_BIN}"

# [TIMEOUTS]
# NOTES:
# - These settings control various timeout durations within the WinApps setup.
# - Increasing the timeouts is only necessary if the corresponding errors occur.
# - Ensure you have followed all the Troubleshooting Tips in the error message first.

# PORT CHECK
# - The maximum time (in seconds) to wait when checking if the RDP port on Windows is open.
# - Corresponding error: "NETWORK CONFIGURATION ERROR" (exit status 13).
# DEFAULT VALUE: '5'
PORT_TIMEOUT="\${PORT_TIMEOUT}"

# RDP CONNECTION TEST
# - The maximum time (in seconds) to wait when testing the initial RDP connection to Windows.
# - Corresponding error: "REMOTE DESKTOP PROTOCOL FAILURE" (exit status 14).
# DEFAULT VALUE: '30'
RDP_TIMEOUT="\${RDP_TIMEOUT}"

# APPLICATION SCAN
# - The maximum time (in seconds) to wait for the script that scans for installed applications on Windows to complete.
# - Corresponding error: "APPLICATION QUERY FAILURE" (exit status 15).
# DEFAULT VALUE: '60'
APP_SCAN_TIMEOUT="\${APP_SCAN_TIMEOUT}"

# WINDOWS BOOT
# - The maximum time (in seconds) to wait for the Windows VM to boot if it is not running, before attempting to launch an application.
# DEFAULT VALUE: '120'
BOOT_TIMEOUT="\${BOOT_TIMEOUT}"

# FREERDP RAIL HIDEF
# - This option controls the value of the \`hidef\` option passed to the /app parameter of the FreeRDP command.
# - Setting this option to 'off' may resolve window misalignment issues related to maximized windows.
# DEFAULT VALUE: 'on'
HIDEF="\${HIDEF}"
EOFCONF
        chmod 600 "\$CONFIG_PATH"
    fi
	
	source "\$CONFIG_PATH"
	
    # Update \$RDP_SCALE.
    waFixScale
    # Update when \$REMOVABLE_MEDIA is null
    waFixRemovableMedia
    # Update \$AUTOPAUSE_TIME.
    # RemoteApp RDP sessions take, at minimum, 20 seconds to be terminated by the Windows server.
    # Hence, subtract 20 from the timeout specified by the user, as a 'built in' timeout of 20 seconds will occur.
    # Source: https://techcommunity.microsoft.com/t5/security-compliance-and-identity/terminal-services-remoteapp-8482-session-termination-logic/ba-p/246566
    AUTOPAUSE_TIME=\$((AUTOPAUSE_TIME - 20))
    AUTOPAUSE_TIME=\$((AUTOPAUSE_TIME < 0 ? 0 : AUTOPAUSE_TIME))
}

# Name: 'waLastRun'
# Role: Determine the last time this script was run.
function waLastRun() {
    # Declare variables.
    local LAST_RUN_UNIX_TIME=0
    local CURR_RUN_UNIX_TIME=0

    # Store the time this script was run last as a unix timestamp.
    if [ -f "\$LASTRUN_PATH" ]; then
        LAST_RUN_UNIX_TIME=\$(stat -t -c %Y "\$LASTRUN_PATH")
        dprint "LAST_RUN: \${LAST_RUN_UNIX_TIME}"
    fi

    # Update the file modification time with the current time.
    touch "\$LASTRUN_PATH"
    CURR_RUN_UNIX_TIME=\$(stat -t -c %Y "\$LASTRUN_PATH")
    dprint "THIS_RUN: \${CURR_RUN_UNIX_TIME}"
}

# Name: 'waGetFreeRDPCommand'
# Role: Determine the correct FreeRDP command to use.
function waGetFreeRDPCommand() {
    if ! command -v "\${FREERDP_BIN}" >/dev/null 2>&1; then
        echo -e "Please install 'FreeRDP' version 3 to proceed."
        exit 1
    fi

    dprint "Using FreeRDP command '\${FREERDP_BIN}'."

    # Append additional flags or parameters to FreeRDP.
    # These additional flags are loaded prior in 'waLoadConfig'.
    if [[ -n \$RDP_FLAGS ]];then
        FREERDP_COMMAND="\${FREERDP_BIN} \${RDP_FLAGS}"
    else
    	FREERDP_COMMAND="\${FREERDP_BIN}"
    fi
}

# Name: 'waCheckGroupMembership'
# Role: Ensures the current user is part of the required groups.
function waCheckGroupMembership() {
    # Identify groups the current user belongs to.
    # shellcheck disable=SC2155 # Silence warnings regarding masking return values through simultaneous declaration and assignment.
    local USER_GROUPS=\$(id -nG "\$(whoami)")

    if ! echo "\$USER_GROUPS" | grep -qE '\b(libvirt|libvirtd)\b' || \\
       ! echo "\$USER_GROUPS" | grep -qE '\bkvm\b'; then
        waThrowExit "\$EC_NOT_IN_GROUP"
    fi
}

# Name: 'waCheckVMRunning'
# Role: Check if the Windows 'libvirt' VM is running, and attempt to start it if it is not.
function waCheckVMRunning() {
    # Declare exit status variable.
    local EXIT_STATUS=0

    # Declare timer variables.
    local TIME_ELAPSED=0
    local TIME_LIMIT=60
    local TIME_INTERVAL=5

    # Attempt to run the Windows virtual machine.
    # Note: States 'running' and 'idle' do not require intervention, and are not checked for.
    if virsh list --all --name | grep -Fxq -- "\$VM_NAME"; then
        if virsh list --state-shutoff --name | grep -Fxq -- "\$VM_NAME"; then
            dprint "WINDOWS SHUT OFF. BOOTING WINDOWS."
            send_notification_info "4000" "Booting Windows."
            NEEDED_BOOT=true
            virsh start "\$VM_NAME" >/dev/null 2>&1 || EXIT_STATUS=\$EC_FAIL_START
            if virsh list --state-paused --name | grep -Fxq -- "\$VM_NAME"; then
                dprint "WINDOWS PAUSED. RESUMING WINDOWS."
                send_notification_info "4000" "Resuming Windows."
                virsh resume "\$VM_NAME" >/dev/null 2>&1 || EXIT_STATUS=\$EC_FAIL_RESUME
            fi
        elif virsh list --state-paused --name | grep -Fxq -- "\$VM_NAME"; then
            dprint "WINDOWS PAUSED. RESUMING WINDOWS."
            send_notification_info "4000" "Resuming Windows."
            virsh resume "\$VM_NAME" >/dev/null 2>&1 || EXIT_STATUS=\$EC_FAIL_RESUME
        elif virsh list --state-other --name | grep -Fxq -- "\$VM_NAME"; then
            if virsh domstate "\$VM_NAME" | grep -Fxq "in shutdown"; then
                dprint "WINDOWS SHUTTING DOWN. WAITING."
                send_notification_info "4000" "Windows is currently shutting down.\nIt will automatically restart once the shutdown process is complete."
                EXIT_STATUS=\$EC_SD_TIMEOUT
                while (( TIME_ELAPSED < TIME_LIMIT )); do
                    if (virsh list --state-shutoff --name | grep -Fxq -- "\$VM_NAME"); then
                        EXIT_STATUS=0
                        dprint "WINDOWS SHUT OFF. BOOTING WINDOWS."
                        send_notification_info "4000" "Booting Windows."
                        virsh start "\$VM_NAME" >/dev/null 2>&1 || EXIT_STATUS=\$EC_FAIL_START
                        NEEDED_BOOT=true
                        break
                    fi
                    sleep \$TIME_INTERVAL
                    TIME_ELAPSED=\$((TIME_ELAPSED + TIME_INTERVAL))
                done
            elif virsh domstate "\$VM_NAME" | grep -Fxq "crashed"; then
                dprint "WINDOWS CRASHED. DESTROYING WINDOWS."
                send_notification_info "4000" "Windows experienced an unexpected crash.\nAttempting to restart Windows."
                virsh destroy "\$VM_NAME" >/dev/null 2>&1 || EXIT_STATUS=\$EC_FAIL_DESTROY
                if [ "\$EXIT_STATUS" -eq 0 ]; then
                    dprint "WINDOWS DESTROYED. BOOTING WINDOWS."
                    send_notification_info "4000" "Booting Windows."
                    virsh start "\$VM_NAME" >/dev/null 2>&1 || EXIT_STATUS=\$EC_FAIL_START
                    NEEDED_BOOT=true
                fi
            elif virsh domstate "\$VM_NAME" | grep -Fxq "dying"; then
                dprint "WINDOWS DYING. WAITING."
                send_notification_info "4000" "Windows is currently shutting down unexpectedly.\nIt will try to restart once the shutdown process finishes."
                EXIT_STATUS=\$EC_DIE_TIMEOUT
                while (( TIME_ELAPSED < TIME_LIMIT )); do
                    if virsh domstate "\$VM_NAME" | grep -Fxq "crashed"; then
                        EXIT_STATUS=0
                        dprint "WINDOWS CRASHED. DESTROYING WINDOWS."
                        send_notification_info "4000" "Windows experienced an unexpected crash.\nAttempting to restart Windows."
                        virsh destroy "\$VM_NAME" >/dev/null 2>&1 || EXIT_STATUS=\$EC_FAIL_DESTROY
                        if [ "\$EXIT_STATUS" -eq 0 ]; then
                            dprint "WINDOWS DESTROYED. BOOTING WINDOWS."
                            send_notification_info "4000" "Booting Windows."
                            virsh start "\$VM_NAME" >/dev/null 2>&1 || EXIT_STATUS=\$EC_FAIL_START
                            NEEDED_BOOT=true
                        fi
                        break
                    elif virsh list --state-shutoff --name | grep -Fxq -- "\$VM_NAME"; then
                        EXIT_STATUS=0
                        dprint "WINDOWS SHUT OFF. BOOTING WINDOWS."
                        send_notification_info "4000" "Booting Windows."
                        virsh start "\$VM_NAME" >/dev/null 2>&1 || EXIT_STATUS=\$EC_FAIL_START
                        NEEDED_BOOT=true
                        break
                    fi
                    sleep \$TIME_INTERVAL
                    TIME_ELAPSED=\$((TIME_ELAPSED + TIME_INTERVAL))
                done
            elif virsh domstate "\$VM_NAME" | grep -Fxq "pmsuspended" ; then
                dprint "WINDOWS SUSPENDED. RESUMING WINDOWS."
                virsh resume "\$VM_NAME" >/dev/null 2>&1 || EXIT_STATUS=\$EC_FAIL_RESUME
            fi
        fi
    else
        EXIT_STATUS=\$EC_NOT_EXIST
    fi

    # Handle non-zero exit statuses.
    [ "\$EXIT_STATUS" -ne 0 ] && waThrowExit "\$EXIT_STATUS"

    # Wait for VM to be fully ready
    if [[ "\$NEEDED_BOOT" == "true" ]]; then
        dprint "WAITING FOR VM TO BE FULLY READY..."
        send_notification_info "4000" "Waiting for Windows to be ready..."

        TIME_ELAPSED=0

        while (( TIME_ELAPSED < BOOT_TIMEOUT )); do
            # Check if VM is running
            if (virsh list --state-running --name | grep -Fxq -- "\$VM_NAME"); then
                # Try to connect to RDP port to verify it's ready
                if timeout 1 bash -c ">/dev/tcp/\$RDP_IP/\$RDP_PORT" 2>/dev/null; then
                    dprint "VM IS READY"
                    send_notification_info "4000" "Windows is ready."
                    # Add a delay after Windows is ready
                    if [ "\$NEEDED_BOOT" = "true" ]; then
                        sleep 10
                    fi
                    break
                fi
            fi

            sleep 5
            TIME_ELAPSED=\$((TIME_ELAPSED + 5))

            # Show progress every 30 seconds
            if (( TIME_ELAPSED % 30 == 0 )); then
                send_notification_info "4000" "Still waiting for Windows to be ready... (\$TIME_ELAPSED seconds elapsed)"
            fi
        done

        # If we timed out waiting for the VM
        if (( TIME_ELAPSED >= BOOT_TIMEOUT )); then
            dprint "TIMEOUT WAITING FOR VM TO BE READY"
            send_notification_info "4000" "Timeout waiting for Windows to be ready. Please try again."
            waThrowExit \$EC_FAIL_START
        fi
    fi
}

# Name: 'waCheckPortOpen'
# Role: Assesses whether the RDP port on Windows is open.
function waCheckPortOpen() {
    # Declare variables.
    local VM_MAC="" # Stores the MAC address of the Windows VM.
    local TIME_ELAPSED=0
    local TIME_LIMIT=30
    local TIME_INTERVAL=5

    # Obtain Windows VM IP Address
    if [ -z "\$RDP_IP" ]; then
        VM_MAC=\$(virsh domiflist "\$VM_NAME" | grep -oE "([0-9A-Fa-f]{2}[:-]){5}([0-9A-Fa-f]{2})") # VM MAC address.

        while (( TIME_ELAPSED < TIME_LIMIT )); do
            if [ "\$TIME_ELAPSED" -eq "\$TIME_INTERVAL" ]; then
                send_notification_info "4000" "Requesting Windows IP address..."
            fi
            RDP_IP=\$(ip neigh show | grep "\$VM_MAC" | grep -oE "([0-9]{1,3}\.){3}[0-9]{1,3}") # VM IP address.
            [ -n "\$RDP_IP" ] && break
            sleep \$TIME_INTERVAL
            TIME_ELAPSED=\$((TIME_ELAPSED + TIME_INTERVAL))
        done

        [ -z "\$RDP_IP" ] && waThrowExit "\$EC_NO_IP"
    fi

    # Check for an open RDP port.
    timeout 10 bash -c "</dev/tcp/\$RDP_IP/\$RDP_PORT" >/dev/null 2>&1 || waThrowExit "\$EC_BAD_PORT"
}

# Name: 'waRunCommand'
# Role: Run the requested WinApps command.
function waRunCommand() {
    # Declare variables.
    local ICON=""
    local FILE_PATH=""

    # Run option.
    if [ "\$1" = "windows" ]; then
        # Update timeout (since there is no 'in-built' 20 second delay for full RDP sessions post-logout).
        AUTOPAUSE_TIME=\$((AUTOPAUSE_TIME + 20))

        # Open Windows RDP session.
        dprint "WINDOWS"
        \$FREERDP_COMMAND \\
            /cert:ignore \\
            /d:"\$RDP_DOMAIN" \\
            /u:"\$RDP_USER" \\
            /p:"\$RDP_PASS" \\
            /scale:"\$RDP_SCALE" \\
            +auto-reconnect \\
            +dynamic-resolution \\
            /wm-class:"Microsoft Windows" \\
            /t:"Windows RDP Session [\$RDP_IP]" \\
            /v:"\$RDP_IP" >/dev/null 2>&1 &

        # Capture the process ID.
        FREERDP_PID=\$!
    else
        if [ -e "\${TARGET_APPDATA_PATH}/apps/\${1}/info" ]; then
            # shellcheck source=/dev/null # Exclude this file from being checked by ShellCheck.
            source "\${TARGET_APPDATA_PATH}/apps/\${1}/info"
            ICON="\${TARGET_APPDATA_PATH}/apps/\${1}/icon.svg"
        else
            waThrowExit "\$EC_UNSUPPORTED_APP"
        fi

        # Check if a file path was specified, and pass this to the application.
        if [ -z "\$2" ]; then
            # No file path specified.
            \$FREERDP_COMMAND \\
                /cert:ignore \\
                /d:"\$RDP_DOMAIN" \\
                /u:"\$RDP_USER" \\
                /p:"\$RDP_PASS" \\
                /scale:"\$RDP_SCALE" \\
                +auto-reconnect \\
                /wm-class:"\$FULL_NAME" \\
                /app:program:"\$WIN_EXECUTABLE",hidef:"\$HIDEF",icon:"\$ICON",name:"\$FULL_NAME" \\
                /v:"\$RDP_IP" >/dev/null 2>&1 &

            # Capture the process ID.
            FREERDP_PID=\$!
        else
            # Convert path from UNIX to Windows style.
            FILE_PATH=\$(echo "\$2" | sed \\
                -e 's|^'"\${HOME}"'|\\\\\\\\tsclient\\\\home|' \\
                -e 's|^'"\${REMOVABLE_MEDIA}"'|\\\\\\\\tsclient\\\\media|' \\
                -e 's|/|\\\\|g')
            dprint "UNIX_FILE_PATH: \${2}"
            dprint "WINDOWS_FILE_PATH: \${FILE_PATH}"

            \$FREERDP_COMMAND \\
                /cert:ignore \\
                /d:"\$RDP_DOMAIN" \\
                /u:"\$RDP_USER" \\
                /p:"\$RDP_PASS" \\
                /scale:"\$RDP_SCALE" \\
                +auto-reconnect \\
                /drive:media,"\$REMOVABLE_MEDIA" \\
                /wm-class:"\$FULL_NAME" \\
                /app:program:"\$WIN_EXECUTABLE",hidef:"\$HIDEF",icon:"\$ICON",name:"\$FULL_NAME",cmd:\""\$FILE_PATH"\" \\
                /v:"\$RDP_IP" >/dev/null 2>&1 &

            # Capture the process ID.
            FREERDP_PID=\$!
        fi
    fi

    if [ "\$FREERDP_PID" -ne -1 ]; then
        # Create a file with the process ID.
        touch "\${USER_APPDATA_PATH}/FreeRDP_Process_\${FREERDP_PID}.cproc"

        # Wait for the process to terminate.
        wait \$FREERDP_PID

        # Remove the file with the process ID.
        rm "\${USER_APPDATA_PATH}/FreeRDP_Process_\${FREERDP_PID}.cproc" >/dev/null 2>&1
    fi
}

# Name: 'waCheckIdle'
# Role: Suspend Windows if idle.
function waCheckIdle() {
    # Declare variables
    local TIME_INTERVAL=10
    local TIME_ELAPSED=0
    local SUSPEND_WINDOWS=0

    # Prevent 'autopause' functionality with unsupported Windows backends.
        # Check if there are no WinApps-related FreeRDP processes running.
        if ! ls "\${USER_APPDATA_PATH}"/FreeRDP_Process_*.cproc >/dev/null 2>&1; then
            SUSPEND_WINDOWS=1
            while (( TIME_ELAPSED < AUTOPAUSE_TIME )); do
                if ls "\${USER_APPDATA_PATH}"/FreeRDP_Process_*.cproc >/dev/null 2>&1; then
                    SUSPEND_WINDOWS=0
                    break
                fi
                sleep \$TIME_INTERVAL
                TIME_ELAPSED=\$((TIME_ELAPSED + TIME_INTERVAL))
            done
        fi

        # Hibernate/Pause Windows.
        if [ "\$SUSPEND_WINDOWS" -eq 1 ]; then
            dprint "IDLE FOR \${AUTOPAUSE_TIME} SECONDS. SUSPENDING WINDOWS."
            send_notification_other "8000" "info" "Pausing Windows due to inactivity."
            virsh suspend "\$VM_NAME" >/dev/null 2>&1
        fi
}

# Name: 'waTimeSync'
# Role: Detect if system went to sleep by comparing uptime progression, then sync time in Windows VM
function waTimeSync() {
    local CURRENT_TIME
    local CURRENT_UPTIME
    local STORED_TIME=0
    local STORED_UPTIME=0
    local EXPECTED_UPTIME=0
    local UPTIME_DIFF=0

    CURRENT_TIME=\$(date +%s)
    CURRENT_UPTIME=\$(awk '{print int(\$1)}' /proc/uptime)

    # Read stored values if file exists
    if [ -f "\$SLEEP_DETECT_PATH" ]; then
        STORED_TIME=\$(head -n1 "\$SLEEP_DETECT_PATH" 2>/dev/null || echo 0)
        STORED_UPTIME=\$(tail -n1 "\$SLEEP_DETECT_PATH" 2>/dev/null || echo 0)
    fi

    if [ "\$STORED_TIME" -gt 0 ] && [ "\$STORED_UPTIME" -gt 0 ]; then
        # Calculate what uptime should be now
        EXPECTED_UPTIME=\$((STORED_UPTIME + CURRENT_TIME - STORED_TIME))
        UPTIME_DIFF=\$((EXPECTED_UPTIME - CURRENT_UPTIME))

        dprint "UPTIME_DIFF: \${UPTIME_DIFF} seconds"

        # If uptime is significantly less than expected, system likely slept
        if [[ "\$UPTIME_DIFF" -gt 30 && ! -f "\$SLEEP_MARKER" ]]; then
            dprint "DETECTED SLEEP/WAKE CYCLE (uptime gap: \${UPTIME_DIFF}s). CREATING SLEEP MARKER TO SYNC WINDOWS TIME."

            # Create sleep marker which will be monitored by Windows VM to trigger time sync
            touch "\$SLEEP_MARKER"

            dprint "CREATED SLEEP MARKER"
        fi
    fi

    # Store current values
    {
        echo "\$CURRENT_TIME"
        echo "\$CURRENT_UPTIME"
    } > "\$SLEEP_DETECT_PATH"
}

### MAIN LOGIC ###
#set -x # Enable for debugging.
mkdir -p "\${USER_APPDATA_PATH}"
dprint "START"
dprint "SCRIPT_DIR: \$(basename "\${BASH_SOURCE[0]}")"
dprint "SCRIPT_ARGS: \${*}"
dprint "HOME_DIR: \${HOME}"
waLastRun
waLoadConfig
waGetFreeRDPCommand
waCheckGroupMembership
waCheckVMRunning
waCheckPortOpen
waTimeSync
waRunCommand "\$@"

if [[ "\$AUTOPAUSE" == "on" ]]; then
    waCheckIdle
fi

dprint "END"
EOF
    chmod +x "${TEMP_BIN_PATH}/winapps"
}

Create_powershell_script() {
        tee "$PS_SCRIPT_PATH" << 'EOF' > /dev/null 2>&1
### FUNCTIONS ###
# Name: 'GetApplicationIcon'
# Role: Extract the icon from a given executable file as a base-64 string.
# Args:
#    - 'exePath': Provides the path to the executable file.
Function GetApplicationIcon {
    param (
        [Parameter(Mandatory = $true)]
        [string]$exePath
    )

    try {
        # Load the 'System.Drawing' assembly to access 'ExtractAssociatedIcon'.
        Add-Type -AssemblyName System.Drawing

        # Extract the icon from the executable.
        $exeIcon = [System.Drawing.Icon]::ExtractAssociatedIcon($exePath)

        # Create a bitmap from the icon.
        $exeIconBitmap = New-Object System.Drawing.Bitmap $exeIcon.Width, $exeIcon.Height
        $graphics = [System.Drawing.Graphics]::FromImage($exeIconBitmap)
        $graphics.DrawIcon($exeIcon, 0, 0)

        # Save the bitmap to a 'MemoryStream' as a '.PNG' to preserve the icon colour depth.
        $memoryStream = New-Object System.IO.MemoryStream
        $exeIconBitmap.Save($memoryStream, [System.Drawing.Imaging.ImageFormat]::Png)

        # Convert the PNG 'MemoryStream' to a base-64 string.
        $bytes = $memoryStream.ToArray()
        $base64String = [Convert]::ToBase64String($bytes)

        # Clean up.
        $memoryStream.Flush()
        $memoryStream.Dispose()
        $graphics.Dispose()
        $exeIconBitmap.Dispose()
        $exeIcon.Dispose()
    } catch {
        # Use a generic 32x32 PNG.
        $base64String = "iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAMAAABEpIrGAAAAAXNSR0IB2cksfwAAAAlwSFlzAAALEwAACxMBAJqcGAAAASZQTFRFAAAA+vr65ubm4uLkhYmLvL7A7u7w+/r729vb4eHjFYPbFoTa5eXnGIbcG4jc+fn7Gofc7+/x7OzuF4Xb+fn54uLiC37Z5OTmEIHaIIjcEYHbDoDZFIPcJ43fHYjd9fX28PDy3d3fI4rd3d3dHojc19fXttTsJIve2dnZDX/YCn3Y09PTjL/p5+fnh7zo2traJYzfIYjdE4Pb6urrW6Tf9PT1Ioneir7otNPsCX3Zhbvn+Pj5YKfhJYfWMo7a39/gKIzeKo7eMI3ZNJDcXqbg4eHhuNTsB3zYIoncBXvZLIrXIYjbLJDgt7m6ubu+YqjiKYvYvr6+tba3rs/sz8/P1+byJonXv7/DiImLxsbGjo6Ra6reurq6io6QkJKVw8PD0tLSycnJq1DGywAAAGJ0Uk5TAP////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////+BVJDaAAABY0lEQVR4nM2RaVOCUBSGr1CBgFZimppgoGnKopZSaYGmRpravq///0904IqOM9j00WeGT+9ztgtCS8Dzyh98fL6i2+HqQoaj0RPSzQNgzZc4F4wgvUuoqkr1er094MjlIeBCwRdFua9CqURQ51cty7Lykj0YCIIibnlEkS4TgCuky3nbTmSFsCKSHuso96N/Ox1aacjrlYQQ3gjNCYV7UlUJ6szCeRZyXmlkNjEZEPSuLIMAuYTreVYROQ8Y8SLTNAhlCdfzLMsaIhfHgEAT7pLtvFTH9QxTNWrmLsaEDu8558y2ZOP5LLNTNUQyiCFnHaRZnjTmzryhnR36FSdnIU9up7RGxAOuKJjOFX2vHvKU5jPiepbvxzR3BIffwROc++AAJy9qjQxQwz9rIjyGeN6tj8VACEyZCqfQn3H7F48vTvwEdlIP+aWvMNkPcl8h8DYeN5vNTqdzCNz5CIv4h7AE/AKcwUFbShJywQAAAABJRU5ErkJggg=="
    }

    # Return the base-64 string.
    return $base64String
}

# Name: 'PrintArrayData'
# Role: Print application names, executable paths and base-64 encoded icons in a format suitable for importing into bash arrays.
# Args:
#    - 'Names': An array of application names.
#    - 'Paths': An array of executable paths.
#    - 'Source': The source of the applications (e.g. Windows Registry, Package managers, Universal Windows Platform (UWP), etc.)
function PrintArrayData {
    param (
        [string[]]$Names,
        [string[]]$Paths,
        [string]$Source
    )

    # Combine the arrays into an array of objects
    $NamesandPaths = @()
    for ($i = 0; $i -lt $Names.Length; $i++) {
        $NamesandPaths += [PSCustomObject]@{
            Name = $Names[$i]
            Path = $Paths[$i]
        }
    }

    # Sort the combined array based on the application names.
    $NamesandPaths = $NamesandPaths | Sort-Object {$_.Name}

    # Loop through the extracted executable file paths.
    foreach ($Application in $NamesandPaths) {

        # Remove undesirable suffix for chocolatey shims.
        if ($Source -eq "choco") {
            if ($Application.Name.EndsWith(" - Chocolatey Shim")) {
                $Application.Name = $Application.Name.Substring(0, $Application.Name.Length - " - Chocolatey Shim".Length)
            }
        }

        # Add the appropriate tag to the application name.
        if ($Source -ne "winreg") {
            $Application.Name = $Application.Name + " [" + $Source.ToUpper() + "]"
        }

        # Store the application icon as a base-64 string.
        $Icon = GetApplicationIcon -exePath $Application.Path

        # Output the results as bash commands that append the results to several bash arrays.
        Write-Output ('NAMES+=("' + $Application.Name + '")')
        Write-Output ('EXES+=("' + $Application.Path + '")')
        Write-Output ('ICONS+=("' + $Icon + '")')
    }
}

# Name: 'GetApplicationName'
# Role: Determine the application name for a given executable file.
# Args:
#    - 'exePath': The path to a given executable file.
function GetApplicationName {
    param (
        [string]$exePath
    )

    try {
        $productName = (Get-Item $exePath).VersionInfo.FileDescription.Trim() -replace '\s+', ' '
    } catch {
        $productName = [System.IO.Path]::GetFileNameWithoutExtension($exePath)
    }

    return $productName
}

# Name: 'GetUWPApplicationName'
# Role: Determine the application name for a given UWP application.
# Args:
#    - 'exePath': The path to a given executable file.
function GetUWPApplicationName {
    param (
        [string]$exePath
    )

    # Query the application executable for the application name.
    if (Test-Path $exePath) {
        $productName = GetApplicationName -exePath $exePath
    }

    # Use the 'DisplayName' (if available) if the previous method failed.
    if (-not $productName -and $app.DisplayName) {
        $productName = $app.DisplayName
    }

    # Use the 'Name' (if available) as a final fallback.
    if (-not $productName -and $app.Name) {
        $productName = $app.Name
    }

    return $productName
}

# Name: 'GetUWPExecutablePath'
# Role: Obtain the UWP application executable path from 'AppxManifest.xml'.
# Args:
#    - 'instLoc': UWP application folder path (C:\Program Files\WindowsApps\*).
function GetUWPExecutablePath {
    param (
        [string]$instLoc
    )

    # Determine the path to 'AppxManifest.xml' for the selected application.
    $manifestPath = Join-Path -Path $instLoc -ChildPath "AppxManifest.xml"

    if (Test-Path $manifestPath) {
        # Parse the XML file.
        [xml]$manifest = Get-Content $manifestPath
        $applications = $manifest.Package.Applications.Application

        # Return the path to the first executable specified within the XML.
        foreach ($application in $applications) {
            $executable = $application.Executable
            if ($executable) {
                return Join-Path -Path $instLoc -ChildPath $executable
            }
        }
    }

    # Return 'null' if nothing was found.
    return $null
}

# Name: 'AppSearchWinReg'
# Role: Search the Windows Registry for installed applications.
function AppSearchWinReg {
    # Initialise empty arrays.
    $exeNames = @()
    $exePaths = @()
    $validPaths = @()

    # Query windows registry for unique installed executable files.
    $exePaths = Get-ItemProperty "HKLM:\SOFTWARE\Microsoft\Windows\CurrentVersion\App Paths\*" |
        ForEach-Object { $_."(default)" } |  # Extract the value of the (default) property
        Where-Object { $_ -ne $null } |  # Filter out null values
        Sort-Object -Unique  # Ensure uniqueness

    # Remove leading and trailing double quotes from all paths.
    $exePaths = $exePaths -replace '^"*|"*$'

    # Get corresponding application names for unique installed executable files.
    foreach ($exePath in $exePaths) {
        if (Test-Path -Path $exePath) {
            $validPaths += $exePath
            $exeNames += GetApplicationName -exePath $exePath
        }
    }

    # Process extracted executable file paths.
    PrintArrayData -Names $exeNames -Paths $validPaths -Source "winreg"
}

# Name: 'AppSearchUWP'
# Role: Search for 'non-system' UWP applications.
function AppSearchUWP {
    # Initialise empty arrays.
    $exeNames = @()
    $exePaths = @()

    # Obtain all 'non-system' UWP applications using 'Get-AppxPackage'.
    $uwpApps = Get-AppxPackage | Where-Object {
        $_.IsFramework -eq $false -and
        $_.IsResourcePackage -eq $false -and
        $_.SignatureKind -ne 'System'
    }

    # Create an array to store UWP application details.
    $uwpAppDetails = @()

    # Loop through each UWP application.
    foreach ($app in $uwpApps) {
        # Initialise the variable responsible for storing the UWP application name.
        $productName = $null

        # Obtain the path to the UWP application executable.
        $exePath = GetUWPExecutablePath -instLoc $app.InstallLocation

        # Proceed only if an executable path was identified.
        if ($exePath) {
            $productName = GetUWPApplicationName -exePath $exePath

            # Ignore UWP applications with no name, or those named 'Microsoft® Windows® Operating System'.
            if ($productName -ne "Microsoft® Windows® Operating System" -and [string]::IsNullOrEmpty($productName) -eq $false) {
                # Store the UWP application name and executable path.
                $exeNames += $productName
                $exePaths += $exePath
            }
        }
    }

    # Process extracted executable file paths.
    PrintArrayData -Names $exeNames -Paths $exePaths -Source "uwp"
}

# Name: 'AppSearchChocolatey'
# Role: Search for chocolatey shims.
function AppSearchChocolatey {
    # Initialise empty arrays.
    $exeNames = @()
    $exePaths = @()

    # Specify the 'chocolatey' shims directory.
    $chocoDir = "C:\ProgramData\chocolatey\bin"

    # Check if the 'chocolatey' shims directory exists.
    if (Test-Path -Path $chocoDir -PathType Container) {
        # Get all shim '.exe' files.
        $shimExeFiles = Get-ChildItem -Path $chocoDir -Filter *.exe

        # Loop through each '.shim' file to extract the executable path.
        foreach ($shimExeFile in $shimExeFiles) {
            # Resolve the shim to the actual executable path.
            $exePath = (Get-Command $shimExeFile).Source

            # Proceed only if an executable path was identified.
            if ($exePath) {
                $exeNames += GetApplicationName -exePath $exePath
                $exePaths += $exePath
            }
        }

        # Process extracted executable file paths.
        PrintArrayData -Names $exeNames -Paths $exePaths -Source "choco"
    }
}

# Name: 'AppSearchScoop'
# Role: Search for scoop shims.
function AppSearchScoop {
    # Initialise empty arrays.
    $exeNames = @()
    $exePaths = @()

    # Specify the 'scoop' shims directory.
    $scoopDir = "$HOME\scoop\shims"

    # Check if the 'scoop' shims directory exists.
    if (Test-Path -Path $scoopDir -PathType Container) {
        # Get all '.shim' files.
        $shimFiles = Get-ChildItem -Path $scoopDir -Filter *.shim

        # Loop through each '.shim' file to extract the executable path.
        foreach ($shimFile in $shimFiles) {
            # Read the content of the '.shim' file.
            $shimFileContent = Get-Content -Path $shimFile.FullName

            # Extract the path using regex, exiting the loop after the first match is found.
            $exePath = ""

            foreach ($line in $shimFileContent) {
                # '^\s*path\s*=\s*"([^"]+)"'
                # ^       --> Asserts the start of the line.
                # \s*     --> Matches any whitespace characters (zero or more times).
                # path    --> Matches the literal string "path".
                # \s*=\s* --> Matches an equal sign = surrounded by optional whitespace characters.
                # "       --> Matches an initial double quote.
                # ([^"]+) --> Captures one or more characters that are not ", representing the path inside the double quotes.
                # "       --> Matches a final double quote.
                if ($line -match '^\s*path\s*=\s*"([^"]+)"') {
                    $exePath = $matches[1]
                    break
                }
            }

            if ($exePath -ne "") {
                $exeNames += GetApplicationName -exePath $exePath
                $exePaths += $exePath
            }
        }

        # Process extracted executable file paths.
        PrintArrayData -Names $exeNames -Paths $exePaths -Source "scoop"
    }
}

### SEQUENTIAL LOGIC ###
# Print bash commands to define three new arrays.
Write-Output 'NAMES=()'
Write-Output 'EXES=()'
Write-Output 'ICONS=()'

# Search for installed applications.
AppSearchWinReg     # Windows Registry
if (Get-Command Get-AppxPackage -ErrorAction SilentlyContinue){
    AppSearchUWP        # Universal Windows Platform
}
AppSearchChocolatey # Chocolatey Package Manager
AppSearchScoop      # Scoop Package Manager
EOF
}

move_2_correct_location(){
    $_SUPERUSER mkdir -p "$BIN_PATH"
    $_SUPERUSER mkdir -p "$APP_PATH"
    $_SUPERUSER mkdir -p "${TARGET_APPDATA_PATH}"
    
    $_SUPERUSER chown -R root:root "$TEMP_PATH"
    
    $_SUPERUSER cp -rf "$TEMP_BIN_PATH"/* "$BIN_PATH"
    $_SUPERUSER cp -rf "$TEMP_APP_PATH"/* "$APP_PATH"
    $_SUPERUSER cp -rf "$TEMP_TARGET_APPDATA_PATH"/* "${TARGET_APPDATA_PATH}"
	
	$_SUPERUSER ln -sf "$BIN_PATH"/* "${__distro_path_bin}"
	$_SUPERUSER ln -sf "$APP_PATH"/* "/usr/share/applications"
	
    $_SUPERUSER rm -rdf "$TEMP_PATH"
}

waCheckScriptDependencies

mkdir -p "${TEMP_PATH}"
mkdir -p "${TEMP_BIN_PATH}"
mkdir -p "${TEMP_APP_PATH}"
mkdir -p "${TEMP_TARGET_APPDATA_PATH}/apps"
mkdir -p "${TEMP_TARGET_APPDATA_PATH}/icons"
    
chmod -R 700 "$TEMP_PATH"

if [ ! -f "${TEMP_BIN_PATH}/winapps" ];then
    say "Creating winapps"
    Create_winapps_script
fi
if [ ! -f "${TEMP_TARGET_APPDATA_PATH}/icons/windows.svg" ];then
    say "Creating windows.svg"
    windows_base64_ICON="PHN2ZyB2ZXJzaW9uPSIxLjIiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIgdmlld0JveD0iMCAwIDIwNDggMjA0OCIgd2lkdGg9IjIwNDgiIGhlaWdodD0iMjA0OCI+CiAgPHRpdGxlPldpbmRvd3M8L3RpdGxlPgogIDxkZWZzPgogICAgPGxpbmVhckdyYWRpZW50IGlkPSJnMSIgeDI9IjEiIGdyYWRpZW50VW5pdHM9InVzZXJTcGFjZU9uVXNlIiBncmFkaWVudFRyYW5zZm9ybT0ibWF0cml4KC0yMDQ4LC0yMDQ4LDIwNDgsLTIwNDgsMjA0OCwyMDQ4KSI+CiAgICAgIDxzdG9wIG9mZnNldD0iMCIgc3RvcC1jb2xvcj0iIzA2N2NkNiIvPgogICAgICA8c3RvcCBvZmZzZXQ9Ii40IiBzdG9wLWNvbG9yPSIjMGY4NWRhIi8+CiAgICAgIDxzdG9wIG9mZnNldD0iMSIgc3RvcC1jb2xvcj0iIzdhZGNmZiIvPgogICAgPC9saW5lYXJHcmFkaWVudD4KICA8L2RlZnM+CiAgPHBhdGggaWQ9IldpbmRvd3MiIGZpbGw9InVybCgjZzEpIiBmaWxsLXJ1bGU9ImV2ZW5vZGQiIGNsYXNzPSJzMCIgZD0ibTIyOCAwaDc0NnY5NzRoLTk3NHYtNzQ2YzAtMTI1LjkgMTAyLjEtMjI4IDIyOC0yMjh6bTc0NiAyMDQ4aC03NDZjLTEyNS45IDAtMjI4LTEwMi4xLTIyOC0yMjh2LTc0Nmg5NzR6bTg0Ni0yMDQ4YzEyNS45IDAgMjI4IDEwMi4xIDIyOCAyMjh2NzQ2aC05NzR2LTk3NHptMjI4IDE4MjBjMCAxMjUuOS0xMDIuMSAyMjgtMjI4IDIyOGgtNzQ2di05NzRoOTc0eiIvPgo8L3N2Zz4K"
    echo "$windows_base64_ICON" | base64 --decode | tee "${TEMP_TARGET_APPDATA_PATH}/icons/windows.svg" >/dev/null 2>&1
fi
if [ ! -f "$PS_SCRIPT_PATH" ];then
    say "Creating ExtractPrograms.ps1"
    Create_powershell_script
fi

waInstall
move_2_correct_location

say "INSTALLATION COMPLETE." 'green'
exit 0
