#!/bin/bash
### General Variables ###
use_external_menu="${1:-fzf}"
tv_config_dir="${2:-}"
shift 2
if [ "$use_external_menu" = "rofi" ];then
	ROFI_THEME="${3:-}"
	ROFI_STYLE="${4:-}"
	shift 2
fi

tv_config_file="${tv_config_dir}/movie"
tmp_dir="/tmp/movies"
movies_socket="$tmp_dir/movies.sock" # Used by mpv (check the play_video function)
movies_logfile="$tmp_dir/movies.log"
tmp_applications_dir="$tmp_dir"
tmp_applications_path="$tmp_applications_dir/applications" # Used for external menus (for now just rofi)
images_cache_dir="$tmp_dir/movies-images"             # Used for storing downloaded images of movie covers
STATE=""                                               # Used for main state machine

# Constants
nl='
' # Literal newline for use in pattern matching
# These are not arbitrary, but determined by rofi kb-custom-1 and kb-custom-2 exit codes
BACK_CODE=10
FORWARD_CODE=11

### OS Specific Variables ###
separator=':'             # default value
path_thing="\\"           # default value
ueberzugpp_tmp_dir="$tmp_dir/ueberzugpp"

data_dir="$HOME/.local/share/movies"
API_URL="https://dec.eatmynerds.live"
base="flixhq.to"
provider="Vidcloud"
subs_language="english"
histfile_name="movies_history.txt"
histfile_dir="$data_dir"
history=false
image_preview="false"
preview_window_size="right:60%:wrap"
ueberzug_x=10
ueberzug_y=3
remove_tmp_movies="true"
json_output="false"
watchlater_dir="$tmp_dir/watchlater"
quality="1080"
no_subs="false"
debug="false"
notify="true"
image_preview_tool_are="auto"

if [ ! -f "$tv_config_file" ];then
	if [ ! -d "$tv_config_dir" ];then
		mkdir -p "$tv_config_dir"
	fi
    tee "$tv_config_file" <<- EOF >/dev/null 2>&1
    #################################################
    # Movie
    #################################################
    data_dir="$data_dir"
    API_URL="$API_URL"
    base="$base"
    provider="$provider"
    subs_language="$subs_language"
    histfile_dir="$histfile_dir"
    histfile_name="$histfile_name"
    history="$history"
    image_preview="$image_preview"
    image_preview_tool_are="$image_preview_tool_are"
    preview_window_size="$preview_window_size"
    ueberzug_x="$ueberzug_x"
    ueberzug_y="$ueberzug_y"
    remove_tmp_movies="$remove_tmp_movies"
    json_output="$json_output"
    watchlater_dir="$watchlater_dir"
    quality="$quality"
    no_subs="$no_subs"
    debug="$debug"
    notify="$notify"
EOF
fi

ueberzug_max_width=$(($(tput lines) / 2))
ueberzug_max_height=$(($(tput lines) / 2))
histfile="$histfile_dir/$histfile_name"

#shellcheck disable=1090
. "$tv_config_file"

# send_notification [message] [timeout] [icon] [title]
if [ "$notify" = "true" ]; then
	send_notification() {
    	[ "$json_output" = "true" ] && return
    	if [ "$use_external_menu" = "fzf" ]; then
        	if [ -z "$4" ];then
        		printf "\33[2K\r\033[1;34m%s\n\033[0m" "$1" && return
        	else
        		printf "\33[2K\r\033[1;34m%s - %s\n\033[0m" "$1" "$4" && return
        	fi
    	fi
    	timeout="${1:-3000}" # default timeout is 3 seconds
		if [ -z "$3" ];then
			notify-send "$1" "$4" -t "$timeout" -h string:x-dunst-stack-tag:vol # the -h string:x-dunst-stack-tag:vol is used for overriding previous notifications
		else
			notify-send "$1" "$4" -t "$timeout" -i "$3" -h string:x-dunst-stack-tag:vol
		fi
	}
else
	send_notification() {
    	[ "$json_output" = "true" ] && return
    	if [ "$use_external_menu" = "fzf" ]; then
        	if [ -z "$4" ];then
        		printf "\33[2K\r\033[1;34m%s\n\033[0m" "$1" && return
        	else
        		printf "\33[2K\r\033[1;34m%s - %s\n\033[0m" "$1" "$4" && return
        	fi
    	fi
	}
fi

if [ "$image_preview" = true ] && [ "$use_external_menu" = "fzf" ] && [ "$image_preview_tool_are" = auto ];then
    if { [ -n "$KITTY_WINDOW_ID" ] || [ -n "$GHOSTTY_RESOURCES_DIR" ]; } && command -v kitten >/dev/null 2>&1; then
    	image_preview_tool_are="kitten"
    elif command -v "ueberzugpp" >/dev/null 2>&1;then
    	image_preview_tool_are="ueberzugpp"
	elif command -v "chafa" >/dev/null 2>&1;then
    	image_preview_tool_are="chafa"
	else
    	send_notification "Program \"ueberzugpp or chafa\" not found. Please install it, if you want to use it for image previews"
        exit 1
	fi
fi

workon_getURL(){
    mode="${1-}"
    url="${2-}"
    path="${3-}"

    if [ "${mode}" = "2term" ];then
        curl -s "${url}" || exit 1
    elif [ "${mode}" = "download2" ];then
        curl -s -o "$path" "${url}" || exit 1
    fi
}

cleanup() {
    if [ "$debug" = "true" ];then
        remove_tmp_movies=false
    fi
    if [ "$remove_tmp_movies" = "true" ];then
        rm -rf "$tmp_dir"
    fi
    set +x && exec 2>&-
}
trap cleanup EXIT INT TERM

### Help Function ###
usage() {
	scriptname="${0##*/}"
    printf "
  Usage: %s [options] [query]
  If a query is provided, it will be used to search for a Movie/TV Show

  Options:
    -c, --continue
      Continue watching from current history
    -h, --help
      Show this help message and exit
    -r, --recent [movies|tv]
      Lets you select from the most recent movies or tv shows (if no argument is provided, it defaults to movies)
  Note:
    All arguments can be specified in the config file as well.
    If an argument is specified in both the config file and the command line, the command line argument will be used.

  Some example usages:
    %s a silent voice

" "${scriptname}" "${scriptname}"
}

if [ ! -d "$watchlater_dir" ];then
    mkdir -p "$watchlater_dir"
fi
if [ ! -d "$histfile_dir" ];then
    mkdir -p "$histfile_dir"
fi
if [ ! -d "$data_dir" ];then
    mkdir -p "$data_dir"
fi
if [ ! -d "$tmp_dir" ];then
    mkdir -p "$tmp_dir"
fi
if [ ! -d "$tmp_applications_path" ];then
    mkdir -p "$tmp_applications_path"
fi
if [ ! -d "$images_cache_dir" ];then
    mkdir -p "$images_cache_dir"
fi
# The reason I use additional file descriptors is because of the use of tee
# which when piped into would hijack the terminal, which was unwanted behavior
# since there are SSH use cases for mpv and since I wanted to have a logging mechanism
exec 3>&1 4>&2 1>"$movies_logfile" 2>&1
{
    # A launcher is a utility used to select an option from a list (fzf, rofi)
    # launcher [prompt] [columns-to-display]
	if [ "$use_external_menu" = "rofi" ]; then
		launcher() {
			if [ -z "$2" ];then
            	rofi -kb-mode-next "" -kb-mode-previous "" -kb-custom-1 Shift+Left -kb-custom-2 Shift+Right -sort -dmenu -i -width 1500 -p "" -mesg "$1" -theme "$ROFI_THEME"
            else
            	rofi -kb-mode-next "" -kb-mode-previous "" -kb-custom-1 Shift+Left -kb-custom-2 Shift+Right -sort -dmenu -i -width 1500 -p "" -mesg "$1" -display-columns "$2" -theme "$ROFI_THEME"
            fi
            # Gives rc=10 on pressing kb-custom-1 and rc=11 on pressing kb-custom-2
            rc=$?
            return "$rc"
		}
		rofi_show_icons(){
			monitor_res=$(($(xdpyinfo | awk '/dimensions/{print $2}' | cut -d 'x' -f1) * 17 / $(xdpyinfo | awk '/resolution/{print $2}' | cut -d 'x' -f1)))
            rofi_override="element-icon{size:${monitor_res}px;}"
            line=""
            cd "${images_cache_dir}"
            find . -maxdepth 1 -type f -print0 | while IFS= read -r -d '' line; do
                img_name="${line#./}"
                printf "%s\0icon\x1f%s/%s\n" "$img_name" "${images_cache_dir}" "$img_name"
            done | rofi -dmenu -theme "$HOME/.config/rofi/$ROFI_STYLE/RiceSelector.rasi" -theme-str "$rofi_override"
		}
	elif [ "$use_external_menu" = "fzf" ]; then
     	launcher() {
            if [ -z "$2" ];then
              	fzf_out=$(fzf --bind "shift-right:accept" --expect=shift-left --cycle --reverse --prompt "$1")
            else
              	fzf_out=$(fzf --bind "shift-right:accept" --expect=shift-left --cycle --reverse --prompt "$1" --with-nth "$2" -d "\t")
            fi
            rc=$?
            # Uses fzf expect to look for back button press
            case $fzf_out in
            	shift-left"$nl"*)
					rc="$BACK_CODE"
					fzf_out=${fzf_out#*"$nl"}
				;;
				"$nl"*) fzf_out=${fzf_out#"$nl"} ;;
				*) exit 1 ;; # Should not reach here
			esac
            printf '%s\n' "$fzf_out"
            return "$rc"
        }
        
        fzf_show_choose(){
        	fzf --bind "shift-right:accept" --expect=shift-left --cycle --reverse --with-nth 4 -d "\t" --header "$1"
        }
        
        get_preview_dim() {
            cols=${FZF_PREVIEW_COLUMNS}
            lines=${FZF_PREVIEW_LINES}

            if [ -z "$cols" ] || [ -z "$lines" ]; then
                lines=$(tput lines)
                cols=$(tput cols)
            fi

            dim="${cols}x${lines}"

            # Adjust if preview is at the bottom to avoid scrolling issues with Sixel
            if [ -z "$KITTY_WINDOW_ID" ] && [ "$((FZF_PREVIEW_TOP + lines))" -eq "$lines" ]; then
                dim="${cols}x$((lines - 1))"
            fi

            echo "$dim"
        }

        export images_cache_dir

        if [ "$image_preview_tool_are" = "kitten" ];then
            preview_command() {
                dim=$(get_preview_dim)
                # 'memory' transfer mode is fastest; 'stream' allows scroll but slower
                RESET=$(printf '\033[m')
                kitten icat --clear --transfer-mode=memory --unicode-placeholder --stdin=no --place="${dim}@0x0" "$images_cache_dir/$1" \
                    | sed '$d' | sed $'$s/$/\e[m/'	# Remove last newline and append ANSI reset
            }
        elif [ "$image_preview_tool_are" = "ueberzugpp" ];then
            preview_command() {
                :
            }
        elif [ "$image_preview_tool_are" = "chafa" ];then
            preview_command() {
                dim=$(get_preview_dim)
                chafa -s "$dim" "$images_cache_dir/$1"
            }
        fi
        
        export -f preview_command get_preview_dim
	fi
    # helper function to be able to display only an "nth" column in fzf/rofi without altering the stdin
    nth() {
        stdin=$(cat -)
        [ -z "$stdin" ] && return 1
        prompt="$1"
        [ $# -ne 1 ] && shift
        line=$(printf "%s" "$stdin" | sed -nE "s@^(.*)\t[0-9:]*\t[0-9]*\t(tv|movie)(.*)@\1 (\2)\t\3@p" | cut -f1-3,6,7 | tr '\t' '|' | launcher "$prompt" | cut -d "|" -f 1)
        [ -n "$line" ] && printf "%s" "$stdin" | sed -nE "s@^$line\t(.*)@\1@p" || exit 1
    }

    ### User Prompts ###
    prompt_to_continue() {
        if [ "$media_type" = "tv" ]; then
            continue_choice=$(printf "Next episode\nReplay episode\nExit\nSearch" | launcher "Select: ")
        else
            continue_choice=$(printf "Exit\nSearch" | launcher "Select: ")
        fi
        rc=$?
        [ "$rc" -eq "$BACK_CODE" ] && exit 0
    }

    ### Searching/Selecting ###
    get_input() {
        if [ "$use_external_menu" = "fzf" ]; then
            printf "Search Movie/TV Show: " && read -r query
        elif [ "$use_external_menu" = "rofi" ]; then
            query=$(printf "" | launcher "Search Movie/TV Show")
        fi
        rc=$?
        # rofi return exit code 1 when user submits custom text, so check >1 for exit
        [ "$rc" -gt 1 ] && exit 0
        [ -n "$query" ] && query=$(echo "$query" | tr ' ' '-')
        if [ -z "$query" ]; then
            send_notification "Error" "1000" "" "No query provided"
            exit 1
        fi
    }
    search() {
        response=$(workon_getURL '2term' "https://${base}/search/$1" | sed ':a;N;$!ba;s/\n//g;s/class="flw-item"/\n/g' |
            sed -nE "s@.*img data-src=\"([^\"]*)\".*<a href=\".*/(tv|movie)/watch-.*-([0-9]*)\".*title=\"([^\"]*)\".*class=\"fdi-item\">([^<]*)</span>.*@\1\t\3\t\2\t\4 [\5]@p")
        [ -z "$response" ] && send_notification "Error" "1000" "" "No results found" && exit 1
    }
    choose_search() {
        if [ -z "$response" ]; then
            [ -z "$query" ] && get_input
            search "$query"
            [ -z "$response" ] && exit 1
        fi
        STATE="MEDIA"
    }
    choose_media() {
        if [ "$image_preview" = "true" ]; then
            maybe_download_thumbnails "$response"
            select_desktop_entry ""
            rc=$?
        else
            if [ "$use_external_menu" = "rofi" ]; then
                choice=$(printf "%s" "$response" | launcher "Choose a Movie or TV Show" 4)
                rc=$?
            elif [ "$use_external_menu" = "fzf" ]; then
                choice=$(printf "%s" "$response" | fzf_show_choose "Choose a Movie or TV Show")
                rc=$?
                # Check for back-button
                case $choice in
                    shift-left"$nl"*)
                        rc="$BACK_CODE"
                        choice=${choice#*"$nl"}
                        ;;
                    "$nl"*) choice=${choice#*"$nl"} ;;
                    *) exit 1 ;;
                esac
            fi
            image_link=$(printf "%s" "$choice" | cut -f1)
            media_id=$(printf "%s" "$choice" | cut -f2)
            title=$(printf "%s" "$choice" | sed -nE "s@.* *(tv|movie)[[:space:]]*(.*) \[.*\]@\2@p")
            media_type=$(printf "%s" "$choice" | sed -nE "s@.* *(tv|movie)[[:space:]]*(.*) \[.*\]@\1@p")
        fi

        # Check if back button pressed
        if [ "$rc" -eq "$BACK_CODE" ]; then
            STATE="SEARCH"
            response=""
            query=""
            choice=""
            return 0
        # Don't exit on rc="$FORWARD_CODE", it means rofi kb-custom-2 was pressed
        elif [ "$rc" -ne 0 ] && [ "$rc" -ne "$FORWARD_CODE" ]; then
            exit 0
        fi

        if [ "$media_type" = "tv" ]; then
            STATE="SEASON"
        else
            keep_running="true"
            STATE="PLAY"
        fi
    }
    choose_season() {
        season_line=$(
            workon_getURL '2term' "https://${base}/ajax/v2/tv/seasons/${media_id}" |
                sed -nE 's@.*href=".*-([0-9]*)">(.*)</a>@\2\t\1@p' |
                launcher "Select a season: " "1"
        )
        rc=$?
        if [ "$rc" -eq "$BACK_CODE" ]; then
            STATE="MEDIA"
            return 0
        elif [ "$rc" -ne 0 ] && [ "$rc" -ne "$FORWARD_CODE" ]; then
            exit 0
        fi

        [ -z "$season_line" ] && exit 1

        season_title=$(printf '%s' "$season_line" | cut -f1)
        season_id=$(printf '%s' "$season_line" | cut -f2)
        STATE="EPISODE"
    }
    choose_episode() {
        ep_line=$(
            workon_getURL '2term' "https://${base}/ajax/v2/season/episodes/${season_id}" |
                sed ':a;N;$!ba;s/\n//g;s/class="nav-item"/\n/g' |
                sed -nE 's@.*data-id="([0-9]*)".*title="([^"]*)">.*@\2\t\1@p' |
                launcher "Select an episode: " "1"
        )
        rc=$?

        if [ "$rc" -eq "$BACK_CODE" ]; then
            STATE="SEASON"
            return 0
        elif [ "$rc" -ne 0 ] && [ "$rc" -ne "$FORWARD_CODE" ]; then
            exit 0
        fi

        episode_title=$(printf '%s' "$ep_line" | cut -f1)
        data_id=$(printf '%s' "$ep_line" | cut -f2)

        episode_id=$(
            workon_getURL '2term' "https://${base}/ajax/v2/episode/servers/${data_id}" |
                sed ':a;N;$!ba;s/\n//g;s/class="nav-item"/\n/g' |
                sed -nE 's@.*data-id="([0-9]*)".*title="([^"]*)".*@\1\t\2@p' |
                grep "$provider" | cut -f1 | head -n1
        )

        keep_running="true"
        STATE="PLAY"
    }
    next_episode_exists() {
        episodes_list=$(workon_getURL '2term' "https://${base}/ajax/v2/season/episodes/${season_id}" | sed ':a;N;$!ba;s/\n//g;s/class="nav-item"/\n/g' |
            sed -nE "s@.*data-id=\"([0-9]*)\".*title=\"([^\"]*)\">.*@\2\t\1@p")
        next_episode=$(printf "%s" "$episodes_list" | sed -n "/$data_id/{n;p;}")
        [ -n "$next_episode" ] && return
        tmp_season_id=$(workon_getURL '2term' "https://${base}/ajax/v2/tv/seasons/${media_id}" | sed -n "/href=\".*-$season_id/{n;n;n;n;p;}" | sed -nE "s@.*href=\".*-([0-9]*)\">(.*)</a>@\2\t\1@p")
        [ -z "$tmp_season_id" ] && return
        season_title=$(printf "%s" "$tmp_season_id" | cut -f1)
        season_id=$(printf "%s" "$tmp_season_id" | cut -f2)
        next_episode=$(workon_getURL '2term' "https://${base}/ajax/v2/season/episodes/${season_id}" | sed ':a;N;$!ba;s/\n//g;s/class="nav-item"/\n/g' |
            sed -nE "s@.*data-id=\"([0-9]*)\".*title=\"([^\"]*)\">.*@\2\t\1@p" | head -1)
        [ -n "$next_episode" ] && return
    }

    ### Image Preview ###
    maybe_download_thumbnails() {
        # Only downloads thumbnails again if every thumbnail is not already in images_cache_dir
        need_dl=0
        tab="$(printf '\t')"

        # keep the while-loop in the current shell
        while IFS="$tab" read -r cover_url id type title; do
            [ -z "$cover_url" ] && continue # skip empty lines
            poster="$images_cache_dir/  $title ($type)  $id.jpg"
            if [ ! -f "$poster" ];then
            	download_thumbnails "$cover_url" "$id" "$type" "$title"
            fi
        done <<EOF
$1
EOF
    }
    
    download_thumbnails() {
        pids=""
		cover_url="$1"
		id="$2"
		type="$3"
		title="$4"

        printf '%s\n' "$cover_url" >"$tmp_dir/image_links" # For Discord rich presence

        # Sets res to 1000x1000
        cover_url=$(printf '%s\n' "$cover_url" |
            sed -E 's:/[0-9]+x[0-9]+/:/1000x1000/:')

        poster_path="$images_cache_dir/  $title ($type)  $id.jpg"
        workon_getURL 'download2' "$cover_url" "$poster_path" & pids="$pids $!"
    }

    select_desktop_entry() {
        if [ "$use_external_menu" = "rofi" ]; then
            choice=$(rofi_show_icons "$1")
            rc=$?
        elif [ "$use_external_menu" = "fzf" ]; then
            choice=$(find "$images_cache_dir" -type f -exec basename {} \; | fzf --preview='preview_command {}')
            rc=$?
            tput reset
        fi

        media_id=$(printf "%s" "$choice" | sed -nE 's@.* ([0-9]+)\.jpg@\1@p')
        title=$(printf "%s" "$choice" | sed -nE 's@^[[:space:]]*(.*) \((tv|movie)\)  [0-9]+\.jpg@\1@p')
        media_type=$(printf "%s" "$choice" | sed -nE 's@^[[:space:]]*(.*) \((tv|movie)\)  [0-9]+\.jpg@\2@p')

        return "$rc"
    }

    ### Scraping/Decryption ###
    get_embed() {
        if [ "$media_type" = "movie" ]; then
            # request to get the episode id
            movie_page="https://${base}"$(workon_getURL '2term' "https://${base}/ajax/movie/episodes/${media_id}" |
                sed ':a;N;$!ba;s/\n//g;s/class="nav-item"/\n/g' | sed -nE "s@.*href=\"([^\"]*)\"[[:space:]]*title=\"${provider}\".*@\1@p")
            episode_id=$(printf "%s" "$movie_page" | sed -nE "s_.*-([0-9]*)\.([0-9]*)\$_\2_p")
        fi
        # request to get the embed
        embed_link=$(workon_getURL '2term' "https://${base}/ajax/episode/sources/${episode_id}" | sed -nE "s_.*\"link\":\"([^\"]*)\".*_\1_p")
        if [ -z "$embed_link" ]; then
            send_notification "Error" "Could not get embed link"
            exit 1
        fi
    }

    extract_from_embed() {
        api_url="${API_URL}/?url=${embed_link}"
        json_data=$(workon_getURL '2term' "${api_url}")
        video_link=$(printf "%s" "$json_data" | sed -nE "s_.*\"file\":\"([^\"]*\.m3u8)\".*_\1_p" | head -1)

        [ -n "$quality" ] && video_link=$(printf "%s" "$video_link" | sed -e "s|/playlist.m3u8|/$quality/index.m3u8|")

        [ "$json_output" = "true" ] && printf "%s\n" "$json_data" && exit 0

        if [ "$no_subs" = "true" ]; then
            send_notification "Continuing without subtitles"
        else
            subs_links=$(printf "%s" "$json_data" | tr '{' '\n' | sed -n "s/.*\"file\":\"\([^\"]*\)\".*\"label\":\"[^\"]*${subs_language}[^\"]*\".*/\1/Ip")

            if [ -z "$subs_links" ]; then
                send_notification "No subtitles found for language '$subs_language'"
                subs_arg=""
            else
                subs_arg="--sub-file"
                num_subs=$(printf "%s" "$subs_links" | wc -l)
                if [ "$num_subs" -gt 0 ]; then
                    subs_links=$(printf "%s" "$subs_links" | sed -e "s/:/\\$path_thing:/g" -e "H;1h;\$!d;x;y/\n/$separator/" -e "s/$separator\$//")
                    subs_arg="--sub-files"
                fi
            fi
        fi
    }

    ### History ###
    check_history() {
        if [ ! -f "$histfile" ]; then
            [ "$image_preview" = "true" ] && send_notification "Now Playing" "5000" "$images_cache_dir/  $title ($media_type)  $media_id.jpg" "$title"
            [ "$json_output" != "true" ] && send_notification "Now Playing" "5000" "" "$title"
            return
        fi
        case $media_type in
            movie)
                if grep -q "$media_id" "$histfile"; then
                    resume_from=$(grep "$media_id" "$histfile" | cut -f2)
                    send_notification "Resuming from" "5000" "$images_cache_dir/  $title ($media_type)  $media_id.jpg" "$resume_from"
                else
                    send_notification "Now Playing" "5000" "$images_cache_dir/  $title ($media_type)  $media_id.jpg" "$title"
                fi
                ;;
            tv)
                if grep -q "$media_id" "$histfile"; then
                    if grep -q "$episode_id" "$histfile"; then
                        [ -z "$resume_from" ] && resume_from=$(sed -nE "s@.*\t([0-9:]*)\t$media_id\ttv\t$season_id.*@\1@p" "$histfile")
                        send_notification "$season_title" "5000" "$images_cache_dir/  $title ($media_type)  $media_id.jpg" "$episode_title"
                    fi
                else
                    send_notification "$season_title" "5000" "$images_cache_dir/  $title ($media_type)  $media_id.jpg" "$episode_title"
                fi
                ;;
            *) send_notification "This media type is not supported" ;;

        esac
    }
    save_history() {
        [ -z "$image_link" ] && image_link="$(grep "$media_id" "$tmp_dir/image_links" | cut -f1)"
        case $media_type in
            movie)
                if [ "$progress" -gt "90" ]; then
                    sed -i "/$media_id/d" "$histfile"
                    send_notification "Deleted from history" "5000" "" "$title"
                else
                    if grep -q -- "$media_id" "$histfile" 2>/dev/null; then
                        sed -i "s|\t[0-9:]*\t$media_id|\t$position\t$media_id|1" "$histfile"
                        send_notification "Saved to history" "5000" "" "$title"
                    else
                        printf "%s\t%s\t%s\t%s\t%s\n" "$title" "$position" "$media_id" "$media_type" "$image_link" >>"$histfile"
                        send_notification "Saved to history" "5000" "$images_cache_dir/  $title ($media_type)  $media_id.jpg" "$title"
                    fi
                fi
                ;;
            tv)
                if [ "$progress" -gt "90" ]; then
                    next_episode_exists
                    if [ -n "$next_episode" ]; then
                        position="00:00:00"
                        episode_title=$(printf "%s" "$next_episode" | cut -f1)
                        data_id=$(printf "%s" "$next_episode" | cut -f2)
                        episode_id=$(workon_getURL '2term' "https://${base}/ajax/v2/episode/servers/${data_id}" | sed ':a;N;$!ba;s/\n//g;s/class="nav-item"/\n/g' |
                            sed -nE "s@.*data-id=\"([0-9]*)\".*title=\"([^\"]*)\".*@\1\t\2@p" | grep "$provider" | cut -f1)
                        send_notification "Updated to next episode" "5000" "" "$episode_title"
                    else
                        sed -i "/$media_id/d" "$histfile"
                        send_notification "Completed" "5000" "" "$title"
                        return
                    fi
                else
                    send_notification "Saved to history" "5000" "$images_cache_dir/  $title ($media_type)  $media_id.jpg" "$title"
                fi

                # If entry exists in hist file then update it, otherwise append new line
                if grep -q -- "$media_id" "$histfile" 2>/dev/null; then
                    sed -i "s|^.*\t$media_id\t.*$|$title\t$position\t$media_id\t$media_type\t$season_id\t$episode_id\t$season_title\t$episode_title\t$data_id\t$image_link|" "$histfile"
                else
                    printf "%s\t%s\t%s\t%s\t%s\t%s\t%s\t%s\t%s\t%s\n" "$title" "$position" "$media_id" "$media_type" \
                        "$season_id" "$episode_id" "$season_title" "$episode_title" "$data_id" "$image_link" >>"$histfile"
                fi
                ;;
            *) notify-send "Error" "Unknown media type" ;;
        esac
    }
    
    play_from_history() {
    	2filter=""
        [ ! -f "$histfile" ] && send_notification "No history file found" "5000" "" && exit 1
        [ "$watched_history" = 1 ] && exit 0
        watched_history=1

        if [ "$image_preview" = "true" ]; then
            history_response=$(
                awk -F'\t' '
                {
                    title = $1
                    id    = $3
                    type  = $4
                    cover_url = (type == "tv") ? $10 : $5
                    print cover_url "\t" id "\t" type "\t" title
                }
                ' "$histfile"
            )

            maybe_download_thumbnails "$history_response"
            select_desktop_entry ""
            if [ "$media_type" = "tv" ]; then
                line=$(grep -m1 -F "$media_id" "$histfile")
                2filter="$line"
            fi
        else
            choice=$(sed -n "1h;1!{x;H;};\${g;p;}" "$histfile" | nl -w 1 | nth "Choose an entry: ")
            2filter="$choice"
            [ -z "$choice" ] && exit 1
            title=$(printf "%s" "$choice" | cut -f1)
            resume_from=$(printf "%s" "$choice" | cut -f2)
            media_id=$(printf "%s" "$choice" | cut -f3)
            media_type=$(printf "%s" "$choice" | cut -f4)
        fi
        
        if [ "$media_type" = "tv" ]; then
            season_id=$(printf "%s" "$2filter" | cut -f5)
            episode_id=$(printf "%s" "$2filter" | cut -f6)
            season_title=$(printf "%s" "$2filter" | cut -f7)
            episode_title=$(printf "%s" "$2filter" | cut -f8)
            data_id=$(printf "%s" "$2filter" | cut -f9)
            image_link=$(printf "%s" "$2filter" | cut -f10)
        fi
        
        STATE="PLAY" && keep_running="true" && loop
    }

    ### Video Playback ###
    save_progress() {
        position=$(cat "$watchlater_dir/"* 2>/dev/null | grep -A1 "$video_link" | sed -nE "s@start=([0-9.]*)@\1@p" | cut -d'.' -f1)
        if [ -n "$position" ]; then
            progress=$((position * 100 / total_duration))
            position=$(printf "%02d:%02d:%02d" $((position / 3600)) $((position / 60 % 60)) $((position % 60)))
            send_notification "Stopped at" "5000" "$images_cache_dir/  $title ($media_type)  $media_id.jpg" "$position"
        fi
    }
    play_video() {
        if [ "$media_type" = "tv" ];then
        	displayed_title="$title - $season_title - $episode_title"
        else
        	displayed_title="$title"
        fi
        [ -z "$continue_choice" ] && check_history
        player_cmd="mpv"
        [ -n "$resume_from" ] && player_cmd="$player_cmd --start='$resume_from'"
        [ -n "$subs_links" ] && player_cmd="$player_cmd $subs_arg='$subs_links'"
        # Escape ' symbols in titles to prevent unterminated string error
        escaped_title=$(printf "%s" "$displayed_title" | sed "s/'/'\\\\''/g")
        player_cmd="$player_cmd --force-media-title='$escaped_title' '$video_link'"
        player_cmd="$player_cmd --watch-later-directory='$watchlater_dir' --write-filename-in-watch-later-config --save-position-on-quit --quiet"

        # Check if the system supports Unix domain sockets
        if command -v nc >/dev/null 2>&1 && [ -S "$movies_socket" ] 2>/dev/null; then
            player_cmd="$player_cmd --input-ipc-server='$movies_socket'"
        fi

        # Use eval to properly handle spaces in the command
        eval "$player_cmd" >&3 &

        if [ -z "$quality" ]; then
            link=$(printf "%s" "$video_link" | sed "s/\/playlist.m3u8/\/1080\/index.m3u8/g")
        else
            link=$video_link
        fi

        content=$(workon_getURL '2term' "$link")
        durations=$(printf "%s" "$content" | grep -oE 'EXTINF:[0-9.]+,' | cut -d':' -f2 | tr -d ',')
        total_duration=$(printf "%s" "$durations" | xargs echo | awk '{for(i=1;i<=NF;i++)sum+=$i} END {print sum}' | cut -d'.' -f1)

        wait
        save_progress
    }
    
    choose_from_recent() {
        path=$1
        section=$2
        if [ "$path" = "home" ]; then
            response=$(workon_getURL '2term' "https://${base}/${path}" | sed -n "/id=\"${section}\"/,/class=\"block_area block_area_home section-id-02\"/p" | sed ':a;N;$!ba;s/\n//g;s/class="flw-item"/\n/g' |
                sed -nE "s@.*img data-src=\"([^\"]*)\".*<a href=\".*/(tv|movie)/watch-.*-([0-9]*)\".*title=\"([^\"]*)\".*class=\"fdi-item\">([^<]*)</span>.*@\1\t\3\t\2\t\4 [\5]@p")
        else
            response=$(workon_getURL '2term' "https://${base}/${path}" | sed ':a;N;$!ba;s/\n//g;s/class="flw-item"/\n/g' |
                sed -nE "s@.*img data-src=\"([^\"]*)\".*<a href=\".*/(tv|movie)/watch-.*-([0-9]*)\".*title=\"([^\"]*)\".*class=\"fdi-item\">([^<]*)</span>.*@\1\t\3\t\2\t\4 [\5]@p")
        fi
        main
    }

    ### Main ###
    loop() {
        while [ "$keep_running" = "true" ]; do
            get_embed
            [ -z "$embed_link" ] && exit 1
            extract_from_embed
            [ -z "$video_link" ] && exit 1
            play_video
            next_episode=""
            if [ -n "$position" ] && [ "$history" = "true" ]; then
                save_history
            fi
            prompt_to_continue
            case "$continue_choice" in
                "Next episode")
                    resume_from=""
                    if [ -z "$next_episode" ]; then
                        next_episode_exists
                    fi
                    if [ -n "$next_episode" ]; then
                        episode_title=$(printf "%s" "$next_episode" | cut -f1)
                        data_id=$(printf "%s" "$next_episode" | cut -f2)
                        episode_id=$(workon_getURL '2term' "https://${base}/ajax/v2/episode/servers/${data_id}" | sed ':a;N;$!ba;s/\n//g;s/class="nav-item"/\n/g' | sed -nE "s@.*data-id=\"([0-9]*)\".*title=\"([^\"]*)\".*@\1\t\2@p" | grep "$provider" | cut -f1)
                        send_notification "Watching the next episode" "5000" "" "$episode_title"
                    else
                        send_notification "No more episodes" "5000" "" "$title"
                        exit 0
                    fi
                    continue
                    ;;
                "Replay episode")
                    resume_from=""
                    continue
                    ;;
                "Search")
                    rm -f "$images_cache_dir"/*
                    query=""
                    response=""
                    season_id=""
                    episode_id=""
                    episode_title=""
                    title=""
                    data_id=""
                    resume_from=""
                    main
                    ;;
                *) keep_running="false" && exit ;;
            esac
        done
    }
    main() {
        STATE="SEARCH"
        while :; do
            case "$STATE" in
                SEARCH) choose_search ;;
                MEDIA) choose_media ;;
                SEASON) choose_season ;;
                EPISODE) choose_episode ;;
                PLAY) loop ;;
                EXIT) break ;;
                *) break ;;
            esac
        done
    }

    [ "$debug" = "true" ] && set -x
    query=""
    # Command line arguments parsing
    while [ $# -gt 0 ]; do
        case "$1" in
            --)
                shift
                query="$*"
                break
                ;;
            # TODO: don't immediately exit if --continue is passed, since this ignores other arguments as soon as -c or --continue is found
            -c | --continue) play_from_history && exit ;;
            -h | --help) usage && exit 0 ;;
            -r | --recent)
                recent="$2"
                if [ -z "$recent" ]; then
                    recent="movie"
                    shift
                else
                    if [ "${recent#-}" != "$recent" ]; then
                        recent="movie"
                        shift
                    else
                        shift 2
                    fi
                fi
                ;;
            *)
                if [ "${1#-}" != "$1" ]; then
                    query="$query $1"
                else
                    query="$query $1"
                fi
                shift
                ;;
        esac
    done
    query="$(printf "%s" "$query" | tr ' ' '-' | sed "s/^-//g")"
    
    if [ "$recent" = "movie" ];then
    	choose_from_recent "movie" ""
    elif [ "$recent" = "tv" ];then
    	choose_from_recent "tv-show" ""
    fi

    main

} 2>&1 | tee "$movies_logfile" >&3 2>&4
exec 1>&3 2>&4
