#!/bin/sh
set -e

[ -f "$__distro_path_lib" ] && . "$__distro_path_lib"

show_error() {
    red='\033[0;91m'
    nc='\033[0m'
    printf "%b%s%b\n" "$red" "$*" "$nc" >&2
}

show_info() {
    green='\033[0;92m'
    nc='\033[0m'
    printf "%b%s%b\n" "$green" "$*" "$nc"
}

show_warning() {
    yellow='\033[0;93m'
    nc='\033[0m'
    printf "%b%s%b\n" "$yellow" "$*" "$nc"
}

show_header() {
    cyan='\033[0;96m'
    nc='\033[0m'
    printf "%b%s%b\n" "$cyan" "$*" "$nc"
}

show_listitem() {
    white='\033[0;97m'
    nc='\033[0m'
    printf "  %b%s%b\n" "$white" "$*" "$nc"
}

A_BITRATE_PER_STREAM=64
NO_DEFAULT_SUBS=false
CROP=false
PROBESIZE=1G
ANALYZEDURATION=1G
OUT_VCODEC="copy"
OUT_ACODEC="copy"
ASTREAM_ID=""
VSTREAM_ID=""
EXTRA=""

set_audio_bitrate() {
    _n_channels="$1"
    _in_bitrate="$2"
    _calc_bitrate=$((A_BITRATE_PER_STREAM * _n_channels))

    if [ "$_in_bitrate" = "0" ] || [ "$_in_bitrate" = "N/A" ] || [ -z "$_in_bitrate" ]; then
        echo "${_calc_bitrate}k"
    elif [ "$_calc_bitrate" -gt "$_in_bitrate" ]; then
        echo "${_in_bitrate}k"
    else
        echo "${_calc_bitrate}k"
    fi
}

compute_crop_filter() {
    _file="$1"
    # Using awk to extract the crop value from ffmpeg output
    _crop=$(ffmpeg -i "file:$_file" -vf 'cropdetect=24:2:0' -f null - 2>&1 | tail -n 3 | head -n 1 | awk -F 'crop=' '{print $2}' | cut -d' ' -f1)
    if [ -z "$_crop" ]; then return 1; fi
    echo "crop=$_crop"
}

fill_dimensions() {
    if [ -n "$IN_DIMENSIONS" ]; then
        if [ -z "$OUT_DIMENSIONS" ]; then
            OUT_DIMENSIONS="$IN_DIMENSIONS"
        else
            # Extract width and height
            _owidth=$(echo "$OUT_DIMENSIONS" | cut -d'x' -f1)
            _oheight=$(echo "$OUT_DIMENSIONS" | cut -d'x' -f2)
            _ratio_calc=$(echo "$ASPECTRATIO" | tr ':' '/')

            if [ -z "$_owidth" ] && [ -n "$_oheight" ]; then
                _owidth=$(awk "BEGIN {printf \"%.0f\", $_oheight * ($_ratio_calc)}")
            elif [ -n "$_owidth" ] && [ -z "$_oheight" ]; then
                _oheight=$(awk "BEGIN {printf \"%.0f\", $_owidth / ($_ratio_calc)}")
            fi
            OUT_DIMENSIONS="${_owidth}x${_oheight}"
        fi
    fi
}

convert_codec() {
    _in="$BACKUP"
    _cmd="ffmpeg${PROBESIZE:+ -probesize ${PROBESIZE}}${ANALYZEDURATION:+ -analyzeduration ${ANALYZEDURATION}}"
    _cmd="$_cmd -v info -i \"file:$_in\" -map_chapters 0 -map_metadata 0"

    if [ "$NO_DEFAULT_SUBS" = "true" ]; then
        _cmd="$_cmd -default_mode infer_no_subs -disposition:s -default"
    fi

    # Video Mapping
    if [ "$VSTREAM_ID" != "-1" ]; then
        _cmd="$_cmd -map 0:v:${VSTREAM_ID:-?}"
        if [ "$CROP" = "true" ]; then
            _crop_val=$(compute_crop_filter "$_in") && _cmd="$_cmd -vf '$_crop_val'" || show_warning "No crop detected."
        fi

        case "$OUT_VCODEC" in
            libx264|libx265) _cmd="$_cmd -c:v:${VSTREAM_ID:-0} $OUT_VCODEC -x264-params crf=${CRF} -preset slow" ;;
            copy) _cmd="$_cmd -c:v:${VSTREAM_ID:-0} copy" ;;
        esac
    fi

    # Audio Mapping
    if [ "$ASTREAM_ID" != "-1" ]; then
        _cmd="$_cmd -map 0:a:${ASTREAM_ID:-?}"
        case "$OUT_ACODEC" in
            libfdk_aac) _cmd="$_cmd -c:a libfdk_aac ${OUT_ABITRATE:+ -b:a $OUT_ABITRATE}" ;;
            libopus)    _cmd="$_cmd -c:a libopus ${OUT_ABITRATE:+ -b:a $OUT_ABITRATE}" ;;
            copy)       _cmd="$_cmd -c:a copy" ;;
        esac
    fi

    # Finalize Output
    case "$OUT_CONTAINER" in
        mp4)  _out="${NAME}.mp4"; _cmd="$_cmd -movflags +faststart -f mp4" ;;
        mkv|matroska) _out="${NAME}.mkv"; _cmd="$_cmd -f matroska" ;;
        *)    _out="${NAME}.${OUT_CONTAINER}"; _cmd="$_cmd -f $OUT_CONTAINER" ;;
    esac

    [ -n "$OUT_DIMENSIONS" ] && _cmd="$_cmd -s $OUT_DIMENSIONS"
    [ -n "$EXTRA" ] && _cmd="$_cmd $EXTRA"
    _cmd="$_cmd \"file:$_out\""

    show_header "Executing: $_cmd"
    eval "$_cmd"
}

scan_input() {
    _ffp="ffprobe -v error ${PROBESIZE:+ -probesize ${PROBESIZE}} ${ANALYZEDURATION:+ -analyzeduration ${ANALYZEDURATION}}"
    
    # Get Format
    IN_CONTAINER=$(eval "$_ffp -show_entries format=format_name -of default=noprint_wrappers=1:nokey=1 \"file:$IN\"" | cut -d',' -f1)
    OUT_CONTAINER=${OUT_CONTAINER:-$IN_CONTAINER}

    # Get First Video Stream Info
    _vinfo=$(eval "$_ffp -select_streams v:0 -show_entries stream=width,height,display_aspect_ratio -of csv=p=0 \"file:$IN\"")
    if [ -n "$_vinfo" ]; then
        IN_WIDTH=$(echo "$_vinfo" | cut -d',' -f1)
        IN_HEIGHT=$(echo "$_vinfo" | cut -d',' -f2)
        ASPECTRATIO=$(echo "$_vinfo" | cut -d',' -f3)
        IN_DIMENSIONS="${IN_WIDTH}x${IN_HEIGHT}"
    fi
}

print_usage() {
    show_header "Usage: reencode -i [file] [options]"
    show_listitem "-i | --input      Input file"
    show_listitem "-v | --vcodec     h264, h265, copy"
    show_listitem "-a | --acodec     aac, opus, copy"
    show_listitem "-c | --container  mp4, mkv"
    show_listitem "-r | --crf        CRF value"
    show_listitem "-p | --crop       Auto crop"
}

# --- Parse Args ---
while [ $# -gt 0 ]; do
    case "$1" in
        -i|--input)     IN="$2"; NAME="${IN%.*}"; EXTENSION="${IN##*.}"; BACKUP="${IN}.bak"; scan_input; shift 2 ;;
        -v|--vcodec)    case "$2" in h264*) OUT_VCODEC="libx264" ;; h265*) OUT_VCODEC="libx265" ;; *) OUT_VCODEC="$2" ;; esac; shift 2 ;;
        -a|--acodec)    case "$2" in aac) OUT_ACODEC="libfdk_aac" ;; opus) OUT_ACODEC="libopus" ;; *) OUT_ACODEC="$2" ;; esac; shift 2 ;;
        -c|--container) OUT_CONTAINER="$2"; shift 2 ;;
        -r|--crf)       CRF="$2"; shift 2 ;;
        -p|--crop)      CROP=true; shift ;;
        -h|--help)      print_usage; exit 0 ;;
        *)              shift ;;
    esac
done

if [ -z "$IN" ] || [ ! -f "$IN" ]; then
    show_error "Input file missing or invalid."
    exit 3
fi

if [ "$OUT_VCODEC" = "libx264" ]; then CRF=${CRF:-18}; elif [ "$OUT_VCODEC" = "libx265" ]; then CRF=${CRF:-23}; fi

fill_dimensions
mv "$IN" "$BACKUP"
trap 'mv "$BACKUP" "$IN"; exit 1' INT TERM

convert_codec
show_info "Process complete. Original backed up as $BACKUP"
